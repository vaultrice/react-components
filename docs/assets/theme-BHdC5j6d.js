let X;const _=()=>X;function p(m,e,i,n){return new(i||(i=Promise))((function(r,o){function t(l){try{a(n.next(l))}catch(s){o(s)}}function d(l){try{a(n.throw(l))}catch(s){o(s)}}function a(l){var s;l.done?r(l.value):(s=l.value,s instanceof i?s:new i((function(c){c(s)}))).then(t,d)}a((n=n.apply(m,e||[])).next())}))}const F="NON_LOCAL_STORAGE_LOCAL_ID",Q=(m,e)=>typeof window<"u"&&window.localStorage?window.localStorage.getItem(`${F}:${m}:${e}`):null,Z=(m,e,i)=>{typeof window<"u"&&window.localStorage&&window.localStorage.setItem(`${F}:${m}:${e}`,i)};function ee(m,e,i){return p(this,arguments,void 0,(function*(n,r,o,t={iterations:1e5,hash:"SHA-512",derivedKeyType:{name:"AES-GCM",length:256}}){const d=new TextEncoder,a=yield crypto.subtle.importKey("raw",d.encode(n+":"+r),"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:o,iterations:t?.iterations||1e5,hash:t?.hash||"SHA-512"},a,t?.derivedKeyType||{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}))}function te(m,e){return p(this,arguments,void 0,(function*(i,n,r={algorithm:"AES-GCM"}){const o=new TextEncoder,t=crypto.getRandomValues(new Uint8Array(12)),d=yield crypto.subtle.encrypt({name:r?.algorithm||"AES-GCM",iv:t},i,o.encode(n));return JSON.stringify({iv:btoa(String.fromCharCode(...t)),data:btoa(String.fromCharCode(...new Uint8Array(d)))})}))}function ie(m,e){return p(this,arguments,void 0,(function*(i,n,r={algorithm:"AES-GCM"}){const o=JSON.parse(n),t=new TextDecoder,d=Uint8Array.from(atob(o.iv),(s=>s.charCodeAt(0))),a=Uint8Array.from(atob(o.data),(s=>s.charCodeAt(0))),l=yield crypto.subtle.decrypt({name:r?.algorithm||"AES-GCM",iv:d},i,a);return t.decode(l)}))}let B;B=typeof crypto<"u"&&typeof crypto.randomUUID=="function"?()=>crypto.randomUUID():()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(m=>{const e=16*Math.random()|0;return(m==="x"?e:3&e|8).toString(16)}));var G=B;const U=["error","warn","info","debug"];let ne=class{constructor(e){this.level=e}log(e,i){U.indexOf(this.level)<U.indexOf(e)||console[e](i)}};var R=(m="warn")=>new ne(m);function D(m){let e=m.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4!=0;)e+="=";return atob(e)}function oe(m){if(typeof m!="string")throw new Error("JWT must be a string");const e=m.split(".");if(e.length!==3)throw new Error("JWT should consist of three parts: header.payload.signature");const[i,n,r]=e,o=D(i);let t;try{t=JSON.parse(o)}catch(l){throw new Error("Invalid JWT header JSON: "+l.message)}const d=D(n);let a;try{a=JSON.parse(d)}catch(l){throw new Error("Invalid JWT payload JSON: "+l.message)}return{header:t,payload:a,signatureHex:(function(l){let s="";for(let c=0;c<l.length;c++)s+=l.charCodeAt(c).toString(16).padStart(2,"0");return s})(D(r))}}const y=Symbol("vaultrice/credentials"),A=Symbol("vaultrice/encryptionSettings"),H=Symbol("vaultrice/previousEncryptionSettings"),N=Symbol("vaultrice/errorHandlers"),S=Symbol("vaultrice/ws"),V=Symbol("vaultrice/eventHandlers"),j=Symbol("vaultrice/accessTokenExpiringHandlers"),re={enabled:!0,maxOperations:100,windowMs:6e4,operationDelay:0};let se=class{constructor(e){this.operationHistory=[],this.lastOperationTime=0,this.operationConfig=Object.assign(Object.assign({},re),e||{})}updateConfig(e){this.operationConfig=Object.assign(Object.assign({},this.operationConfig),e)}cleanupHistory(e,i){const n=Date.now()-i,r=e.findIndex((o=>o.timestamp>n));r>0?e.splice(0,r):r===-1&&(e.length=0)}isAllowed(e,i,n){return this.cleanupHistory(e,n),e.length<i}calculateDelay(e,i){if(i===0)return 0;const n=Date.now()-e;return Math.max(0,i-n)}throttleOperation(){return p(this,void 0,void 0,(function*(){if(!this.operationConfig.enabled)return;if(!this.isAllowed(this.operationHistory,this.operationConfig.maxOperations,this.operationConfig.windowMs))throw new Error(`Operation rate limit exceeded. Maximum ${this.operationConfig.maxOperations} operations per ${this.operationConfig.windowMs}ms allowed.`);const e=this.calculateDelay(this.lastOperationTime,this.operationConfig.operationDelay);var i;e>0&&(yield(i=e,new Promise((r=>setTimeout(r,i)))));const n=Date.now();this.operationHistory.push({timestamp:n}),this.lastOperationTime=n}))}getOperationStatus(){return this.cleanupHistory(this.operationHistory,this.operationConfig.windowMs),{enabled:this.operationConfig.enabled,currentCount:this.operationHistory.length,maxOperations:this.operationConfig.maxOperations,windowMs:this.operationConfig.windowMs,remaining:Math.max(0,this.operationConfig.maxOperations-this.operationHistory.length)}}reset(){this.operationHistory.length=0,this.lastOperationTime=0}};var z;function ae(m,e){return Q(m,e)||`${G()}-${G()}`}const C="_undefined_";class L{constructor(e,i={class:C,autoUpdateOldEncryptedValues:!0,logLevel:"warn"}){this.class=C,this[z]=[];let n={class:C,logLevel:"warn"};if(typeof i=="string"?(this.id=i,n={class:C,logLevel:"warn"}):(this.id=i.id||ae(e.projectId,i.class||C),n=i),this.logger=R(n.logLevel),!e||typeof e!="object"||typeof e.projectId!="string")throw new Error("Invalid credentials!");const r=typeof e.apiKey=="string"&&typeof e.apiSecret=="string",o=typeof e.accessToken=="string",t=typeof e.getAccessToken=="function",d=[r,t].filter(Boolean).length,a=o&&!t;if(d===0&&!a)throw new Error("Invalid credentials! Must provide one of: (apiKey + apiSecret), accessToken, or getAccessToken function");if(d>1||a&&d>0)throw new Error("Invalid credentials! Provide only one primary authentication method. You can combine getAccessToken with an initial accessToken for performance.");if((e.apiKey||e.apiSecret)&&!r)throw new Error("Invalid credentials! Both apiKey and apiSecret are required when using direct authentication");if(this.throttleManager=new se(n.throttling),typeof i=="string"||i?.id||Z(e.projectId,i.class||C,this.id),this[y]=Object.assign({},e),typeof this[y].apiKey=="string"||typeof this[y].apiSecret=="string"||typeof this[y].accessToken!="string"&&!e.getAccessToken||(delete this[y].apiKey,delete this[y].apiSecret),e.getAccessToken&&(this.getAccessTokenFn=e.getAccessToken,delete this[y].getAccessToken),this.class=n.class||C,n.passphrase&&n.getEncryptionHandler)throw new Error("Either define a passphrase or a getEncryptionHandler, but not both!");if(n.getEncryptionHandler&&(this.getEncryptionHandler=n.getEncryptionHandler),n.passphrase&&(this.getEncryptionHandler=l=>p(this,void 0,void 0,(function*(){var s,c,h,u;const v=yield ee(n.passphrase,this.id,l.salt,n.keyDerivationOptions),T=!((c=(s=n.keyDerivationOptions)===null||s===void 0?void 0:s.derivedKeyType)===null||c===void 0)&&c.name?{algorithm:(u=(h=n.keyDerivationOptions)===null||h===void 0?void 0:h.derivedKeyType)===null||u===void 0?void 0:u.name}:void 0;return{encrypt:w=>te(v,w,T),decrypt:w=>ie(v,w,T)}}))),n.autoUpdateOldEncryptedValues===void 0&&(n.autoUpdateOldEncryptedValues=!0),this.autoUpdateOldEncryptedValues=n.autoUpdateOldEncryptedValues,n.idSignature&&(this.idSignature=n.idSignature),this.idSignature&&(this.idSignatureKeyVersion=n.idSignatureKeyVersion),t)if(o){this.logger.log("debug","Using token provider with initial access token");try{this.useAccessTokenAndRememberToAcquireTheNext(this[y].accessToken)}catch{this.logger.log("warn","Initial access token is invalid, acquiring new token"),this[y].accessToken=void 0,this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}))}}else this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}));else o||(this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0})))}static executeWithRetry(e,i,n){return p(this,arguments,void 0,(function*(r,o,t,d={}){var a,l,s,c;const{maxRetries:h=3,initialDelay:u=100,maxDelay:v=2e3,backoffMultiplier:T=2}=d;let w,O=0;for(;O<=h;)try{return yield r()}catch(E){w=E;let I=!1,P="";const J=["Please try again in a moment","Please retry","Service temporarily unavailable","temporarily unavailable","try again later"];if(E&&typeof E=="object"){P=E.message||E.toString();const f=(a=E?.cause)===null||a===void 0?void 0:a.code;f&&f.indexOf("retry")>-1?I=!0:P&&(I=J.some((x=>P.toLowerCase().includes(x.toLowerCase()))))}else typeof E=="string"?(P=E,I=J.some((f=>P.toLowerCase().includes(f.toLowerCase())))):(I=E?.name==="TypeError"||((l=E?.message)===null||l===void 0?void 0:l.includes("fetch"))||((s=E?.message)===null||s===void 0?void 0:s.includes("network"))||((c=E?.message)===null||c===void 0?void 0:c.includes("timeout")),P=E?.message||"Unknown error");if(I&&O<h){t&&t.log("warn",`${o} failed (attempt ${O+1}/${h+1}): ${P}. Retrying...`),O++;const f=Math.min(u*Math.pow(T,O-1),v),x=f+Math.random()*(.1*f);t&&t.log("debug",`Waiting ${Math.round(x)}ms before retry attempt ${O+1}`),yield new Promise((q=>setTimeout(q,x)));continue}throw E}throw w}))}static retrieveAccessToken(e,i,n,r){return p(this,void 0,void 0,(function*(){if(typeof e!="string"||!e)throw new Error("projectId not valid!");if(typeof i!="string"||!i)throw new Error("apiKey not valid!");if(typeof n!="string"||!n)throw new Error("apiSecret not valid!");const o={Authorization:`Basic ${btoa(`${i}:${n}`)}`};return typeof r?.origin=="string"&&r?.origin.length>0&&(o.Origin=r.origin),L.executeWithRetry((()=>p(this,void 0,void 0,(function*(){var t;const d=yield fetch(`${L.basePath}/project/${e}/auth/token`,{method:"GET",headers:o}),a=d.headers.get("content-type");let l;if(a)try{a.indexOf("text/plain")===0?l=yield d.text():a.indexOf("application/json")===0&&(l=yield d.json())}catch{l=`${d.status} - ${d.statusText}`}if(!d.ok){if(d.status===403&&l&&((t=l?.cause)===null||t===void 0?void 0:t.code)==="authorizationError.origin.server.notFound"&&(l.message='Failed to retrieve access token: access denied. This is due to an API key origin restriction. If minting a token from a backend for use in a browser, pass the browser-origin when calling retrieveAccessToken() e.g. NonLocalStorage.retrieveAccessToken("projectId", "apiKey", "apiSecret", { origin: req.headers.origin }).'),typeof l=="string")throw new Error(l);if(l)throw l;if(d.status!==404)throw new Error(`${d.status} - ${d.statusText}`)}return l}))),"Token retrieval",R("warn"))}))}useAccessTokenAndRememberToAcquireTheNext(e){if(!e)throw new Error("No accessToken!");const i=this.useAccessToken(e),n=Math.max(i-12e4,1e3);this.logger.log("debug",`Scheduling next token refresh in ${n}ms`),setTimeout((()=>{this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}))}),n)}acquireAccessToken(){return p(this,void 0,void 0,(function*(){try{let e;if(this.getAccessTokenFn){if(this.logger.log("debug","Acquiring access token via custom provider"),e=yield this.getAccessTokenFn(),typeof e!="string"||!e)throw new Error("getAccessToken function must return a non-empty string")}else{if(!this[y].apiKey||!this[y].apiSecret)throw new Error("No authentication method available for token acquisition");this.logger.log("debug","Acquiring access token via API key/secret"),e=yield L.retrieveAccessToken(this[y].projectId,this[y].apiKey,this[y].apiSecret)}this.useAccessTokenAndRememberToAcquireTheNext(e)}catch(e){throw this.logger.log("error",`Access token acquisition failed: ${e?.message||e?.name||e?.type||e}`),e}}))}useAccessToken(e){if(typeof e!="string"||!e)throw new Error("accessToken not valid!");const i=oe(e);this[y].accessToken=e;const n=i.payload.exp-Date.now();if(n-12e4<0)throw new Error("accessToken not valid anymore");return setTimeout((()=>{this[j].forEach((r=>r()))}),Math.max(n-12e4,0)),n}onAccessTokenExpiring(e){this[j].push(e)}offAccessTokenExpiring(e){const i=this[j].indexOf(e);i!==-1&&this[j].splice(i,1)}getEncryptionHandlerForKeyVersion(e){return p(this,void 0,void 0,(function*(){var i,n,r,o;if(e>-1&&(e!==((i=this[A])===null||i===void 0?void 0:i.keyVersion)&&(this[H]&&this[H].length!==0||(yield this.getEncryptionSettings())),e!==((n=this[A])===null||n===void 0?void 0:n.keyVersion))){if(!this[H]||this[H].length===0)throw new Error(`Wrong keyVersion! Found ${e} but you're using ${(r=this[A])===null||r===void 0?void 0:r.keyVersion}`);let t=this[H].find((d=>d.keyVersion===e));if(t||(yield this.getEncryptionSettings()),t=(this[H]||[]).find((d=>d.keyVersion===e)),!t)throw new Error(`Wrong keyVersion! Found ${e} but you're using ${(o=this[A])===null||o===void 0?void 0:o.keyVersion}`);return this.getEncryptionHandler?this.getEncryptionHandler(t):void 0}return this.encryptionHandler}))}handleEncryptionSettings(e){return p(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No getEncryptionHandler defined!");this[A]=e.encryptionSettings,this[H]=e.previousEncryptionSettings,this.encryptionHandler=yield this.getEncryptionHandler(e.encryptionSettings)}))}prepareEncryptionSettings(e){var i,n,r;return{encryptionSettings:{salt:Uint8Array.from(atob((i=e?.encryptionSettings)===null||i===void 0?void 0:i.salt),(o=>o.charCodeAt(0))),keyVersion:(n=e?.encryptionSettings)===null||n===void 0?void 0:n.keyVersion,createdAt:(r=e?.encryptionSettings)===null||r===void 0?void 0:r.createdAt},previousEncryptionSettings:(e?.previousEncryptionSettings||[]).map((o=>({salt:Uint8Array.from(atob(o?.salt),(t=>t.charCodeAt(0))),keyVersion:o?.keyVersion,createdAt:o?.createdAt})))}}getEncryptionSettings(e){return p(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const i=yield this.request("POST",`/cache-encryption/${this.class}/${this.id}`,e&&e>0?{saltLength:e}:{}),n=this.prepareEncryptionSettings(i);return yield this.handleEncryptionSettings(n),n}))}rotateEncryption(e){return p(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const i=yield this.request("POST",`/cache-encryption-rotate/${this.class}/${this.id}`,e&&e>0?{saltLength:e}:{}),n=this.prepareEncryptionSettings(i);return yield this.handleEncryptionSettings(n),n}))}request(e,i,n,r){return p(this,void 0,void 0,(function*(){!this[y].accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken);try{yield this.throttleManager.throttleOperation()}catch(o){throw this.logger.log("error",`Request throttled: ${o?.message}`),o}return L.executeWithRetry((()=>p(this,void 0,void 0,(function*(){var o;const t=this[y].apiKey&&this[y].apiSecret?`Basic ${btoa(`${this[y].apiKey}:${this[y].apiSecret}`)}`:void 0,d=this[y].accessToken?`Bearer ${this[y].accessToken}`:void 0;let a=this[y].accessToken?d:t;if(i==="/auth/token"&&(a=t),!a)throw new Error("No authentication option provided! (apiKey + apiSecret or accessToken)");const l=Object.assign({Authorization:a},r||{}),s=typeof n=="string",c=(o=this[A])===null||o===void 0?void 0:o.keyVersion;c!==void 0&&c>-1&&(l["X-Enc-KV"]=c.toString()),this.idSignature&&(l["X-Id-Sig"]=this.idSignature,this.idSignatureKeyVersion!==void 0&&(l["X-Id-Sig-KV"]=this.idSignatureKeyVersion.toString())),n&&(l["Content-Type"]=s?"text/plain":"application/json");const h=yield fetch(`${L.basePath}/project/${this[y].projectId}${i}`,{method:e,headers:l,body:n?s?n:JSON.stringify(n):void 0}),u=h.headers.get("content-type");let v;if(u)try{u.indexOf("text/plain")===0?v=yield h.text():u.indexOf("application/json")===0&&(v=yield h.json())}catch{v=`${h.status} - ${h.statusText}`}if(!h.ok){if(typeof v=="string")throw new Error(v);if(v)throw v;if(h.status!==404)throw new Error(`${h.status} - ${h.statusText}`)}return v}))),"API request",this.logger)}))}}z=j,L.basePath="https://api.vaultrice.app";var Y;class M extends L{constructor(e,i){var n,r,o,t,d,a,l,s,c,h;super(e,i),this[Y]=new Map,this.pendingEventSetups=new Map,this.reconnectAttempts=0,this.reconnectBaseDelay=1e3,this.reconnectMaxDelay=6e4,this.isConnected=!1,this.pingInterval=2e4,this.pongTimeout=1e4,this.cancelPendingLeave=!1,this.hasJoined=!1,this[N]=[],this[V]=new Map;const u=typeof i=="object"?i:{};this.configuredAutoReconnect=(r=(n=u.connectionSettings)===null||n===void 0?void 0:n.autoReconnect)===null||r===void 0||r,this.autoReconnect=this.configuredAutoReconnect,this.reconnectBaseDelay=(t=(o=u.connectionSettings)===null||o===void 0?void 0:o.reconnectBaseDelay)!==null&&t!==void 0?t:1e3,this.reconnectMaxDelay=(a=(d=u.connectionSettings)===null||d===void 0?void 0:d.reconnectMaxDelay)!==null&&a!==void 0?a:3e4,this.pingInterval=(s=(l=u.connectionSettings)===null||l===void 0?void 0:l.pingInterval)!==null&&s!==void 0?s:2e4,this.pongTimeout=(h=(c=u.connectionSettings)===null||c===void 0?void 0:c.pongTimeout)!==null&&h!==void 0?h:1e4}send(e){return p(this,arguments,void 0,(function*(i,n={transport:"ws"}){var r,o,t,d,a,l;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const s=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(i)):i;if(n.transport==="http"){const u={};!((r=n.auth)===null||r===void 0)&&r.identityToken&&(u["x-vaultrice-auth-token"]=n.auth.identityToken),!((o=n.auth)===null||o===void 0)&&o.userIdSignature&&(u["x-vaultrice-auth-signature"]=n.auth.userIdSignature);try{yield this.request("POST",`/message/${this.class}/${this.id}`,s,u)}catch(v){if(!v||((t=v?.cause)===null||t===void 0?void 0:t.code)!=="conflictError.keyVersion.mismatch")throw v;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),yield this.request("POST",`/message/${this.class}/${this.id}`,s,u)}return}const c=yield this.getWebSocket();try{yield this.throttleManager.throttleOperation()}catch(u){throw this.logger.log("error",`WebSocket message throttled: ${u?.message}`),u}const h={event:"message",payload:s};n.auth&&(h.auth=n.auth),this[A]&&((d=this[A])===null||d===void 0?void 0:d.keyVersion)>-1&&(h.keyVersion=(a=this[A])===null||a===void 0?void 0:a.keyVersion),!((l=n.auth)===null||l===void 0)&&l.userIdSignature&&typeof s=="string"&&(this.encryptionHandler?this.logger.log("warn","User id signature verification will not work in combination with e2e encryption."):this.logger.log("warn","User id signature verification will not work with this payload.")),c.send(JSON.stringify(h))}))}on(e,i,n){this[V].has(e)||this[V].set(e,new Set);const r=this[V].get(e);this.pendingEventSetups.has(e)||this.pendingEventSetups.set(e,new Set);const o=this.pendingEventSetups.get(e);let t;if(e==="error"){if(typeof i!="function")throw new Error("No event handler defined!");const a=i;return this[N].push(a),t={handler:a,wsListener:s=>{try{const c=s?.message||s?.data||s?.type||(typeof s=="string"?s:"WebSocket error occurred");a(new Error(c))}catch{a(new Error("WebSocket error occurred"))}}},r.add(t),o.add(t),void this.getWebSocket(!1).then((s=>{r.has(t)&&o.has(t)&&(s.addEventListener("error",t.wsListener),o.delete(t))}))}if(e==="connect"){if(typeof i!="function")throw new Error("No event handler defined!");return t={handler:i},r.add(t),o.add(t),void this.getWebSocket(!1).then((a=>{o.delete(t)}))}if(e==="disconnect"){if(typeof i!="function")throw new Error("No event handler defined!");const a=i;return t={handler:a,wsListener:()=>a()},r.add(t),o.add(t),void this.getWebSocket(!1).then((s=>{r.has(t)&&o.has(t)&&(s.addEventListener("close",t.wsListener),o.delete(t))}))}const d=(a,l,s=!1)=>{const c=s?a.keyVersion:a.payload.keyVersion;if(c===void 0)return l(a.payload);if(c>-1){if(!this.getEncryptionHandler)return this[N].forEach((u=>u(new Error("Encrypted data, but no passphrase or getEncryptionHandler configured!"))));if(!this.encryptionHandler)return this[N].forEach((u=>u(new Error("Encrypted data, but getEncryptionSettings() not called!"))));let h=a.payload.value;s&&(h=a.payload),this.getEncryptionHandlerForKeyVersion(c).then((u=>u?.decrypt(h))).then((u=>{s?a.payload=JSON.parse(u):a.payload.value=JSON.parse(u),l(a.payload)})).catch((u=>{this[N].forEach((v=>v(u)))}))}};if(e==="message"){if(typeof i!="function")throw new Error("No event handler defined!");const a=i;return t={handler:a,wsListener:l=>{const s=JSON.parse(l.data);s.event==="message"&&d(s,a,!0)}},r.add(t),o.add(t),void this.getWebSocket(!1).then((l=>{r.has(t)&&o.has(t)&&(l.addEventListener("message",t.wsListener),o.delete(t))}))}if(e==="presence:join"){if(typeof i!="function")throw new Error("No event handler defined!");const a=i;return t={handler:a,wsListener:s=>{const c=JSON.parse(s.data);c.event==="presence:join"&&d(c,(h=>{a({connectionId:c?.connectionId,joinedAt:c?.joinedAt,data:h})}),!0)}},r.add(t),o.add(t),void this.getWebSocket(!1).then((s=>{r.has(t)&&o.has(t)&&(s.addEventListener("message",t.wsListener),o.delete(t))}))}if(e==="presence:leave"){if(typeof i!="function")throw new Error("No event handler defined!");const a=i;return t={handler:a,wsListener:s=>{const c=JSON.parse(s.data);c.event==="presence:leave"&&d(c,(h=>{a({connectionId:c?.connectionId,data:h})}),!0)}},r.add(t),o.add(t),void this.getWebSocket(!1).then((s=>{r.has(t)&&o.has(t)&&(s.addEventListener("message",t.wsListener),o.delete(t))}))}if(e!=="setItem"){if(e==="removeItem")if(n===void 0){if(typeof i!="function")throw new Error("No event handler defined!");const a=i;t={handler:a,wsListener:s=>{const c=JSON.parse(s.data);c.event==="removeItem"&&a(c.payload)}},r.add(t),o.add(t),this.getWebSocket(!1).then((s=>{r.has(t)&&o.has(t)&&(s.addEventListener("message",t.wsListener),o.delete(t))}))}else{if(typeof n!="function")throw new Error("No event handler defined!");const a=n,l=i;t={handler:a,wsListener:c=>{const h=JSON.parse(c.data);h.event==="removeItem"&&h.payload.prop===l&&a(h.payload)},itemName:l},r.add(t),o.add(t),this.getWebSocket(!1).then((c=>{r.has(t)&&o.has(t)&&(c.addEventListener("message",t.wsListener),o.delete(t))}))}}else if(n===void 0){if(typeof i!="function")throw new Error("No event handler defined!");const a=i;t={handler:a,wsListener:l=>{const s=JSON.parse(l.data);s.event==="setItem"&&d(s,a)}},r.add(t),o.add(t),this.getWebSocket(!1).then((l=>{r.has(t)&&o.has(t)&&(l.addEventListener("message",t.wsListener),o.delete(t))}))}else{if(typeof n!="function")throw new Error("No event handler defined!");const a=n,l=i;t={handler:a,wsListener:s=>{const c=JSON.parse(s.data);c.event==="setItem"&&c.payload.prop===l&&d(c,a)},itemName:l},r.add(t),o.add(t),this.getWebSocket(!1).then((s=>{r.has(t)&&o.has(t)&&(s.addEventListener("message",t.wsListener),o.delete(t))}))}}off(e,i,n){const r=this[V].get(e),o=this.pendingEventSetups.get(e);if(r){if(e==="error"){if(typeof i!="function")throw new Error("No event handler defined!");const t=i,d=this[N].indexOf(t);d>-1&&this[N].splice(d,1);for(const a of r)if(a.handler===t){this[S]&&a.wsListener&&this[S].removeEventListener("error",a.wsListener),r.delete(a),o?.delete(a);break}}else{let t,d;if(n===void 0){if(typeof i!="function")throw new Error("No event handler defined!");t=i}else{if(typeof n!="function")throw new Error("No event handler defined!");t=n,d=i}for(const a of r){const l=a.handler===t,s=d===void 0||a.itemName===d;if(l&&s){if(this[S]&&a.wsListener){const c=e==="connect"?"open":e==="disconnect"?"close":e==="error"?"error":"message";this[S].removeEventListener(c,a.wsListener)}r.delete(a),o?.delete(a);break}}}r.size===0&&(this[V].delete(e),this.pendingEventSetups.delete(e)),this[V].size===0&&this[N].length===0&&setTimeout((()=>{this[V].size===0&&this[N].length===0&&this.disconnect()}),200)}}connect(){return p(this,void 0,void 0,(function*(){this[S]||(yield this.getWebSocket())}))}disconnect(){return p(this,void 0,void 0,(function*(){this.autoReconnect=!1,this[S]&&(this.hasJoined&&(yield this.leave()),this[S].close(),delete this[S],this[V].clear(),this[N].length=0)}))}getWebSocket(){return p(this,arguments,void 0,(function*(e=!0){if(!this[y].accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken),this[S])return e&&this[S].readyState===WebSocket.CONNECTING?new Promise(((s,c)=>{const h=this[S],u=()=>{h.removeEventListener("open",v),h.removeEventListener("error",T),h.removeEventListener("close",w)},v=()=>{u(),s(h)},T=O=>{u(),c(O||new Error("WebSocket connection failed"))},w=()=>{u(),c(new Error("WebSocket connection closed during opening"))};h.readyState!==WebSocket.OPEN?(h.addEventListener("open",v,{once:!0}),h.addEventListener("error",T,{once:!0}),h.addEventListener("close",w,{once:!0})):s(h)})):this[S];this.autoReconnect=this.configuredAutoReconnect;const i=M.basePath.replace("http","ws"),n=this[y].apiKey&&this[y].apiSecret?`Basic ${btoa(`${this[y].apiKey}:${this[y].apiSecret}`)}`:void 0,r=this[y].accessToken?`Bearer ${this[y].accessToken}`:void 0,o={auth:this[y].accessToken?r:n};this.idSignature&&(o.idSignature=this.idSignature,this.idSignatureKeyVersion!==void 0&&(o.idSignatureKeyVersion=this.idSignatureKeyVersion));const t=new URLSearchParams(o),d=this[S]=new WebSocket(`${i}/project/${this[y].projectId}/ws/${this.class}/${this.id}?${t}`);this.logger.log("info","initializing WebSocket connection...");let a;d.addEventListener("message",(s=>{let c;try{c=typeof s.data=="string"?JSON.parse(s.data):void 0}catch{c=void 0}if(!c||typeof c!="object")return;const h=c.event;if(h){if(h!=="pong")if(h!=="connected"&&h!=="resume:ack"||!c.connectionId){if(h==="error"){const u=c.payload;if(typeof u=="string"&&u.toLowerCase().includes("invalid resume")&&(this.logger.log("warn","server signalled invalid resume token — clearing saved connectionId"),this.connectionId=void 0,typeof s.stopImmediatePropagation=="function"))try{s.stopImmediatePropagation()}catch{}}}else{this.connectionId=c.connectionId,this.isConnected=!0;const u=this[V].get("connect");if(u)for(const v of u)try{v.handler()}catch(T){this.logger.log("error",T)}if(typeof s.stopImmediatePropagation=="function")try{s.stopImmediatePropagation()}catch{}}else if(this.logger.log("debug","received pong"),this.clearPongTimer(),typeof s.stopImmediatePropagation=="function")try{s.stopImmediatePropagation()}catch{}}}));const l=new Promise((s=>{a=s}));return d.addEventListener("open",(()=>{if(this.reconnectAttempts=0,this.connectionId)try{d.send(JSON.stringify({event:"resume",connectionId:this.connectionId}))}catch{}this.startHeartbeat(),typeof a=="function"&&a(d)}),{once:!0}),d.addEventListener("close",(s=>{this.isConnected=!1,this.stopHeartbeat()}),{once:!0}),d.addEventListener("close",(s=>{s?.code===1008&&(this.logger.log("warn","WebSocket closed with 1008 during reconnection"),this.connectionId=void 0),s?.reason&&s?.reason.indexOf("TierLimitExceeded")>-1&&(this.autoReconnect=!1,this.logger.log("error",s.reason),this[N].forEach((v=>v(new Error(s.reason))))),delete this[S];const c=this.hasJoined||this.pendingPresenceOperation==="join",h=this.pendingPresenceOperation==="leave",u=h?void 0:this.currentJoinData||this.lastJoinData;if(this.autoReconnect){const v=()=>p(this,void 0,void 0,(function*(){const T=Math.min(this.reconnectBaseDelay*Math.pow(2,this.reconnectAttempts),this.reconnectMaxDelay);setTimeout((()=>p(this,void 0,void 0,(function*(){let w;this.reconnectAttempts++,this.logger.log("warn",`${this.reconnectAttempts}. reconnection attempt...`);try{delete this[S],w=yield this.getWebSocket(!1)}catch(f){return this.logger.log("error",f?.message||f?.name||f?.type||f),void v()}const O=()=>p(this,void 0,void 0,(function*(){if(this.reconnectAttempts=0,!this[S])return;const f=this[S];for(const[x,q]of this[V])for(const $ of q){let b;x==="connect"||(x==="disconnect"?(b=()=>$.handler(),f.addEventListener("close",b)):x==="error"?(b=k=>{try{const g=k?.message||k?.data||k?.type||(typeof k=="string"?k:"WebSocket error occurred");$.handler(new Error(g))}catch{$.handler(new Error("WebSocket error occurred"))}},f.addEventListener("error",b)):x==="message"?(b=k=>{let g;try{g=typeof k.data=="string"?JSON.parse(k.data):void 0}catch{g=void 0}g&&g.event==="message"&&$.handler(g.payload)},f.addEventListener("message",b)):x==="presence:join"?(b=k=>{let g;try{g=typeof k.data=="string"?JSON.parse(k.data):void 0}catch{g=void 0}g&&g.event==="presence:join"&&$.handler(g.payload)},f.addEventListener("message",b)):x==="presence:leave"?(b=k=>{let g;try{g=typeof k.data=="string"?JSON.parse(k.data):void 0}catch{g=void 0}g&&g.event==="presence:leave"&&$.handler(g.payload)},f.addEventListener("message",b)):x==="setItem"?(b=k=>{let g;try{g=typeof k.data=="string"?JSON.parse(k.data):void 0}catch{g=void 0}g&&g.event==="setItem"&&($.itemName&&g.payload.prop!==$.itemName||$.handler(g.payload))},f.addEventListener("message",b)):x==="removeItem"&&(b=k=>{let g;try{g=typeof k.data=="string"?JSON.parse(k.data):void 0}catch{g=void 0}g&&g.event==="removeItem"&&($.itemName&&g.payload.prop!==$.itemName||$.handler(g.payload))},f.addEventListener("message",b))),b&&($.wsListener=b)}c&&!h&&u&&(yield this.join(u))})),E=()=>{w?.removeEventListener("open",I),w?.removeEventListener("close",P),w?.removeEventListener("error",J)},I=()=>p(this,void 0,void 0,(function*(){yield O(),E()})),P=()=>{E(),v()},J=f=>{this.logger.log("error",f?.message||f?.name||f?.type||f),E(),v()};w.addEventListener("open",I,{once:!0}),w.addEventListener("close",P,{once:!0}),w.addEventListener("error",J,{once:!0}),w.readyState!==WebSocket.CLOSING&&w.readyState!==WebSocket.CLOSED?w.readyState===WebSocket.OPEN&&(yield O(),E()):v()}))),T)}));v()}})),e?l:d}))}clearPongTimer(){this.pongTimer&&(clearTimeout(this.pongTimer),this.pongTimer=void 0)}startPongTimer(){this.clearPongTimer(),this.pongTimer=setTimeout((()=>{var e;this.logger.log("warn","pong timeout — closing socket to reconnect");try{(e=this[S])===null||e===void 0||e.close(1006,"pong timeout")}catch{}}),this.pongTimeout)}stopHeartbeat(){this.pingTimer&&(clearInterval(this.pingTimer),this.pingTimer=void 0),this.clearPongTimer()}startHeartbeat(){this.stopHeartbeat();const e=this[S];if(e&&e.readyState===WebSocket.OPEN)try{e.send(JSON.stringify({event:"ping"})),this.startPongTimer()}catch{}this.pingTimer=setInterval((()=>{const i=this[S];if(i&&i.readyState===WebSocket.OPEN)try{i.send(JSON.stringify({event:"ping"})),this.startPongTimer()}catch{}}),this.pingInterval)}join(e,i){return p(this,void 0,void 0,(function*(){if(this.pendingPresenceOperation==="join")return this.currentJoinData=e,this.lastJoinData=e,this.cancelPendingLeave=!0,void(yield this.pendingPresencePromise);if(this.pendingPresenceOperation==="leave"&&(this.cancelPendingLeave=!0,yield this.pendingPresencePromise),this.pendingPresenceOperation="join",this.currentJoinData=e,this.lastJoinData=e,this.cancelPendingLeave=!1,this.getEncryptionHandler&&!this.encryptionHandler)throw this.pendingPresenceOperation=void 0,new Error("Call getEncryptionSettings() first!");try{yield this.throttleManager.throttleOperation()}catch(r){throw this.pendingPresenceOperation=void 0,this.logger.log("error",`Request throttled: ${r?.message}`),r}const n=p(this,void 0,void 0,(function*(){const r=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(this.currentJoinData)):this.currentJoinData,o=yield this.getWebSocket(),t={event:"presence:join",payload:r};i&&(t.auth=i),this[A]&&this[A].keyVersion>-1&&(t.keyVersion=this[A].keyVersion),i?.userIdSignature&&typeof r=="string"&&(this.encryptionHandler?this.logger.log("warn","User id signature verification will not work in combination with e2e encryption."):this.logger.log("warn","User id signature verification will not work with this payload."));try{o.send(JSON.stringify(t)),this.hasJoined=!0}finally{this.pendingPresenceOperation==="join"&&(this.pendingPresenceOperation=void 0)}}));this.pendingPresencePromise=n;try{yield n}finally{this.pendingPresencePromise=void 0}}))}leave(){return p(this,void 0,void 0,(function*(){if(this.pendingPresenceOperation==="leave")return void(yield this.pendingPresencePromise);if(this.pendingPresenceOperation==="join"){if(yield this.pendingPresencePromise,this.cancelPendingLeave)return void this.logger.log("warn","leave() cancelled - join called while waiting")}else if(!this.hasJoined)return;try{yield this.throttleManager.throttleOperation()}catch(i){throw this.logger.log("error",`Request throttled: ${i?.message}`),i}this.pendingPresenceOperation="leave",this.cancelPendingLeave=!1;const e=p(this,void 0,void 0,(function*(){if(this.cancelPendingLeave)return void this.logger.log("warn","leave() cancelled before sending - join called");const i=yield this.getWebSocket(),n={event:"presence:leave"};this[A]&&this[A].keyVersion>-1&&(n.keyVersion=this[A].keyVersion);try{i.send(JSON.stringify(n)),this.hasJoined=!1,this.currentJoinData=void 0}finally{this.pendingPresenceOperation==="leave"&&(this.pendingPresenceOperation=void 0)}}));this.pendingPresencePromise=e;try{yield e}finally{this.pendingPresencePromise=void 0}}))}getJoinedConnections(){return p(this,void 0,void 0,(function*(){if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const e=yield this.request("GET",`/presence-list/${this.class}/${this.id}`);if(!e||!Array.isArray(e))return[];const i=[];for(const r of e){if(!r?.data){i.push(r);continue}const o=yield this.getEncryptionHandlerForKeyVersion(r.keyVersion),t=o&&typeof r.data=="string"?JSON.parse(yield o.decrypt(r.data)):r.data;i.push(Object.assign(Object.assign({},r),{data:t}))}const n=this.connectionId;if(n){const r=i.findIndex((o=>o.connectionId===n));if(r>0){const o=i.splice(r,1)[0];i.unshift(o)}}return i}))}}Y=V;class de extends M{constructor(e,i){typeof i=="string"?super(e,i):(super(e,i),i?.ttl&&(this.ttl=i?.ttl))}setItem(e,i,n){return p(this,void 0,void 0,(function*(){var r,o;if(!e)throw new Error("No name passed!");if(!i&&i!==0&&i!==""&&i!==!1)throw new Error("No value passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const t=n?.ttl||this.ttl,d=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(i)):i;let a;try{a=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}`,{value:d,ttl:t,ifAbsent:n?.ifAbsent,updatedAt:n?.updatedAt})}catch(s){if(!s||((r=s?.cause)===null||r===void 0?void 0:r.code)!=="conflictError.keyVersion.mismatch")throw s;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),a=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}`,{value:d,ttl:t,ifAbsent:n?.ifAbsent})}const l=a;return l&&{value:l?.value,expiresAt:l?.expiresAt,keyVersion:(o=l?.keyVersion)!==null&&o!==void 0?o:void 0,createdAt:l?.createdAt,updatedAt:l?.updatedAt}}))}setItems(e){return p(this,void 0,void 0,(function*(){var i,n;if(!e||Object.keys(e).length===0)throw new Error("No items passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");for(const t of Object.keys(e)){const d=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e[t].value)):e[t].value;e[t].value=d,(n=e[t]).ttl||(n.ttl=this.ttl)}let r;try{r=yield this.request("POST",`/cache/${this.class}/${this.id}`,e)}catch(t){if(!t||((i=t?.cause)===null||i===void 0?void 0:i.code)!=="conflictError.keyVersion.mismatch")throw t;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),r=yield this.request("POST",`/cache/${this.class}/${this.id}`,e)}const o=r;return Object.keys(o).reduce(((t,d)=>{var a,l,s,c,h,u,v,T,w,O;return t[d]={value:(l=(a=o[d])===null||a===void 0?void 0:a.value)!==null&&l!==void 0?l:null,expiresAt:(c=(s=o[d])===null||s===void 0?void 0:s.expiresAt)!==null&&c!==void 0?c:0,keyVersion:(u=(h=o[d])===null||h===void 0?void 0:h.keyVersion)!==null&&u!==void 0?u:void 0,createdAt:(T=(v=o[d])===null||v===void 0?void 0:v.createdAt)!==null&&T!==void 0?T:0,updatedAt:(O=(w=o[d])===null||w===void 0?void 0:w.updatedAt)!==null&&O!==void 0?O:0},t}),{})}))}getItem(e){return p(this,void 0,void 0,(function*(){var i,n;if(!e)throw new Error("No name passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let r;try{r=yield this.request("GET",`/cache/${this.class}/${this.id}/${e}`)}catch(l){if(!l||((i=l?.cause)===null||i===void 0?void 0:i.code)!=="conflictError.keyVersion.mismatch")throw l;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),r=yield this.request("GET",`/cache/${this.class}/${this.id}/${e}`)}const o=r,t=o?.value;if(!t)return;const d=yield this.getEncryptionHandlerForKeyVersion(o.keyVersion),a=d?JSON.parse(yield d.decrypt(t)):t;return o?.keyVersion>-1&&o.keyVersion!==((n=this[A])===null||n===void 0?void 0:n.keyVersion)&&(this.autoUpdateOldEncryptedValues?(this.logger.log("info",`Item "${e}" has an old encryption and will be automatically updated now by setting it again.`),yield this.setItem(e,a,{ttl:o.expiresAt-Date.now()})):this.logger.log("warn",`Item "${e}" has an old encryption and can be updated by setting it again.`)),{value:a,expiresAt:o.expiresAt,keyVersion:o.keyVersion,createdAt:o.createdAt,updatedAt:o.updatedAt}}))}getItems(e){return p(this,void 0,void 0,(function*(){var i,n;if(!e||e.length===0)throw new Error("No names passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let r;try{r=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,e)}catch(l){if(!l||((i=l?.cause)===null||i===void 0?void 0:i.code)!=="conflictError.keyVersion.mismatch")throw l;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),r=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,e)}const o=r;if(Object.keys(o).length===0)return;const t={},d={};for(const l of Object.keys(o)){const s=o[l],c=s?.value;if(!c)continue;const h=yield this.getEncryptionHandlerForKeyVersion(s.keyVersion),u=h?JSON.parse(yield h.decrypt(c)):c;s?.keyVersion>-1&&s.keyVersion!==((n=this[A])===null||n===void 0?void 0:n.keyVersion)&&(t[l]=s),d[l]={value:u,expiresAt:s.expiresAt,keyVersion:s.keyVersion,createdAt:s.createdAt,updatedAt:s.updatedAt}}const a=Object.keys(t);if(a.length>0)if(this.autoUpdateOldEncryptedValues){this.logger.log("info",`These items "${a.join(",")}" have an old encryption and will be automatically updated now by setting them again.`);const l=a.reduce(((s,c)=>(s[c]={value:d[c].value,ttl:t[c].expiresAt-Date.now()},s)),{});yield this.setItems(l)}else this.logger.log("warn",`These items "${a.join(",")}" have an old encryption and can be updated by setting them again.`);return d}))}getAllItems(e){return p(this,void 0,void 0,(function*(){var i,n;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let r;try{r=yield this.request("GET",`/cache/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}catch(d){if(!d||((i=d?.cause)===null||i===void 0?void 0:i.code)!=="conflictError.keyVersion.mismatch")throw d;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),r=yield this.request("GET",`/cache/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}const o=r;if(Object.keys(o).length===0)return;const t={};for(const d of Object.keys(o)){const a=o[d],l=a?.value;if(!l)continue;const s=yield this.getEncryptionHandlerForKeyVersion(a.keyVersion),c=s?JSON.parse(yield s.decrypt(l)):l;t[d]={value:c,expiresAt:a.expiresAt,keyVersion:(n=a.keyVersion)!==null&&n!==void 0?n:void 0,createdAt:a.createdAt,updatedAt:a.updatedAt}}return t}))}getAllKeys(e){return p(this,void 0,void 0,(function*(){return yield this.request("GET",`/cache-keys/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}))}removeItem(e){return p(this,void 0,void 0,(function*(){if(!e)throw new Error("No name passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}/${e}`)}))}removeItems(e){return p(this,void 0,void 0,(function*(){if(!e||e.length===0)throw new Error("No names passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}`,e)}))}incrementItem(e){return p(this,arguments,void 0,(function*(i,n=1,r){var o;if(!i)throw new Error("No name passed!");if(n==null)throw new Error("No value passed!");if(typeof n!="number")throw new Error("Value needs to be a number!");const t=r?.ttl||this.ttl,d=yield this.request("POST",`/cache/${this.class}/${this.id}/${i}/increment`,{value:n,ttl:t,updatedAt:r?.updatedAt});return{value:d?.value,expiresAt:d?.expiresAt,keyVersion:(o=d?.keyVersion)!==null&&o!==void 0?o:void 0,createdAt:d?.createdAt,updatedAt:d?.updatedAt}}))}decrementItem(e){return p(this,arguments,void 0,(function*(i,n=1,r){var o;if(!i)throw new Error("No name passed!");if(n==null)throw new Error("No value passed!");if(typeof n!="number")throw new Error("Value needs to be a number!");const t=r?.ttl||this.ttl,d=yield this.request("POST",`/cache/${this.class}/${this.id}/${i}/decrement`,{value:n,ttl:t,updatedAt:r?.updatedAt});return{value:d?.value,expiresAt:d?.expiresAt,keyVersion:(o=d?.keyVersion)!==null&&o!==void 0?o:void 0,createdAt:d?.createdAt,updatedAt:d?.updatedAt}}))}push(e,i,n){return p(this,void 0,void 0,(function*(){var r;if(!e)throw new Error("No name passed!");const o=n?.ttl||this.ttl,t=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/push`,{value:i,ttl:o,updatedAt:n?.updatedAt});return{value:t?.value,expiresAt:t?.expiresAt,keyVersion:(r=t?.keyVersion)!==null&&r!==void 0?r:void 0,createdAt:t?.createdAt,updatedAt:t?.updatedAt}}))}splice(e,i,n,r,o){return p(this,void 0,void 0,(function*(){var t;if(!e)throw new Error("No name passed!");const d=o?.ttl||this.ttl,a=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/splice`,{startIndex:i,deleteCount:n,items:r,ttl:d,updatedAt:o?.updatedAt});return{value:a?.value,expiresAt:a?.expiresAt,keyVersion:(t=a?.keyVersion)!==null&&t!==void 0?t:void 0,createdAt:a?.createdAt,updatedAt:a?.updatedAt}}))}merge(e,i,n){return p(this,void 0,void 0,(function*(){var r;if(!e)throw new Error("No name passed!");const o=n?.ttl||this.ttl,t=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/merge`,{value:i,ttl:o,updatedAt:n?.updatedAt});return{value:t?.value,expiresAt:t?.expiresAt,keyVersion:(r=t?.keyVersion)!==null&&r!==void 0?r:void 0,createdAt:t?.createdAt,updatedAt:t?.updatedAt}}))}setIn(e,i,n,r){return p(this,void 0,void 0,(function*(){var o;if(!e)throw new Error("No name passed!");if(!i||i.length===0)throw new Error("Path must not be empty.");const t=r?.ttl||this.ttl,d=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/set-in`,{path:i,value:n,ttl:t,updatedAt:r?.updatedAt});return{value:d?.value,expiresAt:d?.expiresAt,keyVersion:(o=d?.keyVersion)!==null&&o!==void 0?o:void 0,createdAt:d?.createdAt,updatedAt:d?.updatedAt}}))}clear(){return p(this,void 0,void 0,(function*(){yield this.request("DELETE",`/cache/${this.class}/${this.id}`)}))}}const K={};function le(m,e){return`${`${e.projectId}-${e.apiKey}`}-${`${m.class||"_undefined_"}-${m.id}`}`}const ue=(m,e)=>{const i=e||_(),n=le(m,i);if(K[n])return K[n];const r=new de(i,m);return K[n]=r,r};export{ue as e};
