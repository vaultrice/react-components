import{j as g}from"./jsx-runtime-D_zvdyIk.js";import{r as O}from"./iframe-2RVn_JUi.js";import"./preload-helper-D9Z9MdNV.js";let ne;const re=()=>ne;function v(p,e,t,n){return new(t||(t=Promise))((function(s,a){function l(o){try{c(n.next(o))}catch(r){a(r)}}function i(o){try{c(n.throw(o))}catch(r){a(r)}}function c(o){var r;o.done?s(o.value):(r=o.value,r instanceof t?r:new t((function(d){d(r)}))).then(l,i)}c((n=n.apply(p,e||[])).next())}))}const Y="NON_LOCAL_STORAGE_LOCAL_ID",oe=(p,e)=>typeof window<"u"&&window.localStorage?window.localStorage.getItem(`${Y}:${p}:${e}`):null,se=(p,e,t)=>{typeof window<"u"&&window.localStorage&&window.localStorage.setItem(`${Y}:${p}:${e}`,t)};function ae(p,e,t){return v(this,arguments,void 0,(function*(n,s,a,l={iterations:1e5,hash:"SHA-512",derivedKeyType:{name:"AES-GCM",length:256}}){const i=new TextEncoder,c=yield crypto.subtle.importKey("raw",i.encode(n+":"+s),"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:a,iterations:l?.iterations||1e5,hash:l?.hash||"SHA-512"},c,l?.derivedKeyType||{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}))}function ce(p,e){return v(this,arguments,void 0,(function*(t,n,s={algorithm:"AES-GCM"}){const a=new TextEncoder,l=crypto.getRandomValues(new Uint8Array(12)),i=yield crypto.subtle.encrypt({name:s?.algorithm||"AES-GCM",iv:l},t,a.encode(n));return JSON.stringify({iv:btoa(String.fromCharCode(...l)),data:btoa(String.fromCharCode(...new Uint8Array(i)))})}))}function le(p,e){return v(this,arguments,void 0,(function*(t,n,s={algorithm:"AES-GCM"}){const a=JSON.parse(n),l=new TextDecoder,i=Uint8Array.from(atob(a.iv),(r=>r.charCodeAt(0))),c=Uint8Array.from(atob(a.data),(r=>r.charCodeAt(0))),o=yield crypto.subtle.decrypt({name:s?.algorithm||"AES-GCM",iv:i},t,c);return l.decode(o)}))}let z;z=typeof crypto<"u"&&typeof crypto.randomUUID=="function"?()=>crypto.randomUUID():()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(p=>{const e=16*Math.random()|0;return(p==="x"?e:3&e|8).toString(16)}));var B=z;const F=["error","warn","info","debug"];let de=class{constructor(e){this.level=e}log(e,t){F.indexOf(this.level)<F.indexOf(e)||console[e](t)}};var he=(p="warn")=>new de(p);function M(p){let e=p.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4!=0;)e+="=";return atob(e)}function ue(p){if(typeof p!="string")throw new Error("JWT must be a string");const e=p.split(".");if(e.length!==3)throw new Error("JWT should consist of three parts: header.payload.signature");const[t,n,s]=e,a=M(t);let l;try{l=JSON.parse(a)}catch(o){throw new Error("Invalid JWT header JSON: "+o.message)}const i=M(n);let c;try{c=JSON.parse(i)}catch(o){throw new Error("Invalid JWT payload JSON: "+o.message)}return{header:l,payload:c,signatureHex:(function(o){let r="";for(let d=0;d<o.length;d++)r+=o.charCodeAt(d).toString(16).padStart(2,"0");return r})(M(s))}}const m=Symbol("vaultrice/credentials"),A=Symbol("vaultrice/encryptionSettings"),C=Symbol("vaultrice/previousEncryptionSettings"),V=Symbol("vaultrice/errorHandlers"),b=Symbol("vaultrice/ws"),N=Symbol("vaultrice/eventHandlers"),P=Symbol("vaultrice/accessTokenExpiringHandlers"),pe={enabled:!0,maxOperations:100,windowMs:6e4,operationDelay:0};let ge=class{constructor(e){this.operationHistory=[],this.lastOperationTime=0,this.operationConfig=Object.assign(Object.assign({},pe),e||{})}updateConfig(e){this.operationConfig=Object.assign(Object.assign({},this.operationConfig),e)}cleanupHistory(e,t){const n=Date.now()-t,s=e.findIndex((a=>a.timestamp>n));s>0?e.splice(0,s):s===-1&&(e.length=0)}isAllowed(e,t,n){return this.cleanupHistory(e,n),e.length<t}calculateDelay(e,t){if(t===0)return 0;const n=Date.now()-e;return Math.max(0,t-n)}throttleOperation(){return v(this,void 0,void 0,(function*(){if(!this.operationConfig.enabled)return;if(!this.isAllowed(this.operationHistory,this.operationConfig.maxOperations,this.operationConfig.windowMs))throw new Error(`Operation rate limit exceeded. Maximum ${this.operationConfig.maxOperations} operations per ${this.operationConfig.windowMs}ms allowed.`);const e=this.calculateDelay(this.lastOperationTime,this.operationConfig.operationDelay);var t;e>0&&(yield(t=e,new Promise((s=>setTimeout(s,t)))));const n=Date.now();this.operationHistory.push({timestamp:n}),this.lastOperationTime=n}))}getOperationStatus(){return this.cleanupHistory(this.operationHistory,this.operationConfig.windowMs),{enabled:this.operationConfig.enabled,currentCount:this.operationHistory.length,maxOperations:this.operationConfig.maxOperations,windowMs:this.operationConfig.windowMs,remaining:Math.max(0,this.operationConfig.maxOperations-this.operationHistory.length)}}reset(){this.operationHistory.length=0,this.lastOperationTime=0}};var X;function ve(p,e){return oe(p,e)||`${B()}-${B()}`}const H="_undefined_";class q{constructor(e,t={class:H,autoUpdateOldEncryptedValues:!0,logLevel:"warn"}){this.class=H,this[X]=[];let n={class:H,logLevel:"warn"};if(typeof t=="string"?(this.id=t,n={class:H,logLevel:"warn"}):(this.id=t.id||ve(e.projectId,t.class||H),n=t),this.logger=he(n.logLevel),!e||typeof e!="object"||typeof e.projectId!="string")throw new Error("Invalid credentials!");const s=typeof e.apiKey=="string"&&typeof e.apiSecret=="string",a=typeof e.accessToken=="string",l=typeof e.getAccessToken=="function",i=[s,l].filter(Boolean).length,c=a&&!l;if(i===0&&!c)throw new Error("Invalid credentials! Must provide one of: (apiKey + apiSecret), accessToken, or getAccessToken function");if(i>1||c&&i>0)throw new Error("Invalid credentials! Provide only one primary authentication method. You can combine getAccessToken with an initial accessToken for performance.");if((e.apiKey||e.apiSecret)&&!s)throw new Error("Invalid credentials! Both apiKey and apiSecret are required when using direct authentication");if(this.throttleManager=new ge(n.throttling),typeof t=="string"||t?.id||se(e.projectId,t.class||H,this.id),this[m]=Object.assign({},e),typeof this[m].apiKey=="string"||typeof this[m].apiSecret=="string"||typeof this[m].accessToken!="string"&&!e.getAccessToken||(delete this[m].apiKey,delete this[m].apiSecret),e.getAccessToken&&(this.getAccessTokenFn=e.getAccessToken,delete this[m].getAccessToken),this.class=n.class||H,n.passphrase&&n.getEncryptionHandler)throw new Error("Either define a passphrase or a getEncryptionHandler, but not both!");if(n.getEncryptionHandler&&(this.getEncryptionHandler=n.getEncryptionHandler),n.passphrase&&(this.getEncryptionHandler=o=>v(this,void 0,void 0,(function*(){var r,d,h,u;const w=yield ae(n.passphrase,this.id,o.salt,n.keyDerivationOptions),y=!((d=(r=n.keyDerivationOptions)===null||r===void 0?void 0:r.derivedKeyType)===null||d===void 0)&&d.name?{algorithm:(u=(h=n.keyDerivationOptions)===null||h===void 0?void 0:h.derivedKeyType)===null||u===void 0?void 0:u.name}:void 0;return{encrypt:x=>ce(w,x,y),decrypt:x=>le(w,x,y)}}))),n.autoUpdateOldEncryptedValues===void 0&&(n.autoUpdateOldEncryptedValues=!0),this.autoUpdateOldEncryptedValues=n.autoUpdateOldEncryptedValues,n.idSignature&&(this.idSignature=n.idSignature),this.idSignature&&(this.idSignatureKeyVersion=n.idSignatureKeyVersion),l)if(a){this.logger.log("debug","Using token provider with initial access token");try{this.useAccessTokenAndRememberToAcquireTheNext(this[m].accessToken)}catch{this.logger.log("warn","Initial access token is invalid, acquiring new token"),this[m].accessToken=void 0,this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}))}}else this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}));else a||(this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0})))}static retrieveAccessToken(e,t,n,s){return v(this,void 0,void 0,(function*(){var a;if(typeof e!="string"||!e)throw new Error("projectId not valid!");if(typeof t!="string"||!t)throw new Error("apiKey not valid!");if(typeof n!="string"||!n)throw new Error("apiSecret not valid!");const l={Authorization:`Basic ${btoa(`${t}:${n}`)}`};typeof s?.origin=="string"&&s?.origin.length>0&&(l.Origin=s.origin);const i=yield fetch(`${q.basePath}/project/${e}/auth/token`,{method:"GET",headers:l}),c=i.headers.get("content-type");let o;if(c)try{c.indexOf("text/plain")===0?o=yield i.text():c.indexOf("application/json")===0&&(o=yield i.json())}catch{o=`${i.status} - ${i.statusText}`}if(!i.ok){if(i.status===403&&o&&((a=o?.cause)===null||a===void 0?void 0:a.code)==="authorizationError.origin.server.notFound"&&(o.message='Failed to retrieve access token: access denied. This is due to an API key origin restriction. If minting a token from a backend for use in a browser, pass the browser-origin when calling retrieveAccessToken() e.g. NonLocalStorage.retrieveAccessToken("projectId", "apiKey", "apiSecret", { origin: req.headers.origin }).'),typeof o=="string")throw new Error(o);if(o)throw o;if(i.status!==404)throw new Error(`${i.status} - ${i.statusText}`)}return o}))}useAccessTokenAndRememberToAcquireTheNext(e){if(!e)throw new Error("No accessToken!");const t=this.useAccessToken(e),n=Math.max(t-12e4,1e3);this.logger.log("debug",`Scheduling next token refresh in ${n}ms`),setTimeout((()=>{this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}))}),n)}acquireAccessToken(){return v(this,void 0,void 0,(function*(){try{let e;if(this.getAccessTokenFn){if(this.logger.log("debug","Acquiring access token via custom provider"),e=yield this.getAccessTokenFn(),typeof e!="string"||!e)throw new Error("getAccessToken function must return a non-empty string")}else{if(!this[m].apiKey||!this[m].apiSecret)throw new Error("No authentication method available for token acquisition");this.logger.log("debug","Acquiring access token via API key/secret"),e=yield q.retrieveAccessToken(this[m].projectId,this[m].apiKey,this[m].apiSecret)}this.useAccessTokenAndRememberToAcquireTheNext(e)}catch(e){throw this.logger.log("error",`Access token acquisition failed: ${e?.message||e?.name||e?.type||e}`),e}}))}useAccessToken(e){if(typeof e!="string"||!e)throw new Error("accessToken not valid!");const t=ue(e);this[m].accessToken=e;const n=t.payload.exp-Date.now();if(n-12e4<0)throw new Error("accessToken not valid anymore");return setTimeout((()=>{this[P].forEach((s=>s()))}),Math.max(n-12e4,0)),n}onAccessTokenExpiring(e){this[P].push(e)}offAccessTokenExpiring(e){const t=this[P].indexOf(e);t!==-1&&this[P].splice(t,1)}getEncryptionHandlerForKeyVersion(e){return v(this,void 0,void 0,(function*(){var t,n,s,a;if(e>-1&&(e!==((t=this[A])===null||t===void 0?void 0:t.keyVersion)&&(this[C]&&this[C].length!==0||(yield this.getEncryptionSettings())),e!==((n=this[A])===null||n===void 0?void 0:n.keyVersion))){if(!this[C]||this[C].length===0)throw new Error(`Wrong keyVersion! Found ${e} but you're using ${(s=this[A])===null||s===void 0?void 0:s.keyVersion}`);let l=this[C].find((i=>i.keyVersion===e));if(l||(yield this.getEncryptionSettings()),l=(this[C]||[]).find((i=>i.keyVersion===e)),!l)throw new Error(`Wrong keyVersion! Found ${e} but you're using ${(a=this[A])===null||a===void 0?void 0:a.keyVersion}`);return this.getEncryptionHandler?this.getEncryptionHandler(l):void 0}return this.encryptionHandler}))}handleEncryptionSettings(e){return v(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No getEncryptionHandler defined!");this[A]=e.encryptionSettings,this[C]=e.previousEncryptionSettings,this.encryptionHandler=yield this.getEncryptionHandler(e.encryptionSettings)}))}prepareEncryptionSettings(e){var t,n,s;return{encryptionSettings:{salt:Uint8Array.from(atob((t=e?.encryptionSettings)===null||t===void 0?void 0:t.salt),(a=>a.charCodeAt(0))),keyVersion:(n=e?.encryptionSettings)===null||n===void 0?void 0:n.keyVersion,createdAt:(s=e?.encryptionSettings)===null||s===void 0?void 0:s.createdAt},previousEncryptionSettings:(e?.previousEncryptionSettings||[]).map((a=>({salt:Uint8Array.from(atob(a?.salt),(l=>l.charCodeAt(0))),keyVersion:a?.keyVersion,createdAt:a?.createdAt})))}}getEncryptionSettings(e){return v(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const t=yield this.request("POST",`/cache-encryption/${this.class}/${this.id}`,e&&e>0?{saltLength:e}:{}),n=this.prepareEncryptionSettings(t);return yield this.handleEncryptionSettings(n),n}))}rotateEncryption(e){return v(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const t=yield this.request("POST",`/cache-encryption-rotate/${this.class}/${this.id}`,e&&e>0?{saltLength:e}:{}),n=this.prepareEncryptionSettings(t);return yield this.handleEncryptionSettings(n),n}))}request(e,t,n){return v(this,void 0,void 0,(function*(){var s;!this[m].accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken);try{yield this.throttleManager.throttleOperation()}catch(w){throw this.logger.log("error",`Request throttled: ${w?.message}`),w}const a=this[m].apiKey&&this[m].apiSecret?`Basic ${btoa(`${this[m].apiKey}:${this[m].apiSecret}`)}`:void 0,l=this[m].accessToken?`Bearer ${this[m].accessToken}`:void 0;let i=this[m].accessToken?l:a;if(t==="/auth/token"&&(i=a),!i)throw new Error("No authentication option provided! (apiKey + apiSecret or accessToken)");const c={Authorization:i},o=typeof n=="string",r=(s=this[A])===null||s===void 0?void 0:s.keyVersion;r!==void 0&&r>-1&&(c["X-Enc-KV"]=r.toString()),this.idSignature&&(c["X-Id-Sig"]=this.idSignature,this.idSignatureKeyVersion!==void 0&&(c["X-Id-Sig-KV"]=this.idSignatureKeyVersion.toString())),n&&(c["Content-Type"]=o?"text/plain":"application/json");const d=yield fetch(`${q.basePath}/project/${this[m].projectId}${t}`,{method:e,headers:c,body:n?o?n:JSON.stringify(n):void 0}),h=d.headers.get("content-type");let u;if(h)try{h.indexOf("text/plain")===0?u=yield d.text():h.indexOf("application/json")===0&&(u=yield d.json())}catch{u=`${d.status} - ${d.statusText}`}if(!d.ok){if(typeof u=="string")throw new Error(u);if(u)throw u;if(d.status!==404)throw new Error(`${d.status} - ${d.statusText}`)}return u}))}}X=P,q.basePath="https://api.vaultrice.app";var Q;class U extends q{constructor(e,t){var n,s,a,l,i,c,o,r,d,h;super(e,t),this[Q]=new Map,this.reconnectAttempts=0,this.reconnectBaseDelay=1e3,this.reconnectMaxDelay=6e4,this.isConnected=!1,this.pingInterval=2e4,this.pongTimeout=1e4,this.hasJoined=!1,this[V]=[],this[N]=new Map;const u=typeof t=="object"?t:{};this.configuredAutoReconnect=(s=(n=u.connectionSettings)===null||n===void 0?void 0:n.autoReconnect)===null||s===void 0||s,this.autoReconnect=this.configuredAutoReconnect,this.reconnectBaseDelay=(l=(a=u.connectionSettings)===null||a===void 0?void 0:a.reconnectBaseDelay)!==null&&l!==void 0?l:1e3,this.reconnectMaxDelay=(c=(i=u.connectionSettings)===null||i===void 0?void 0:i.reconnectMaxDelay)!==null&&c!==void 0?c:3e4,this.pingInterval=(r=(o=u.connectionSettings)===null||o===void 0?void 0:o.pingInterval)!==null&&r!==void 0?r:2e4,this.pongTimeout=(h=(d=u.connectionSettings)===null||d===void 0?void 0:d.pongTimeout)!==null&&h!==void 0?h:1e4}send(e){return v(this,arguments,void 0,(function*(t,n={transport:"ws"}){var s,a,l;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(t)):t;if(n.transport==="http"){try{yield this.request("POST",`/message/${this.class}/${this.id}`,i)}catch(r){if(!r||((s=r?.cause)===null||s===void 0?void 0:s.name)!=="ConflictError")throw r;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),yield this.request("POST",`/message/${this.class}/${this.id}`,i)}return}const c=yield this.getWebSocket();try{yield this.throttleManager.throttleOperation()}catch(r){throw this.logger.log("error",`WebSocket message throttled: ${r?.message}`),r}const o={event:"message",payload:i};this[A]&&((a=this[A])===null||a===void 0?void 0:a.keyVersion)>-1&&(o.keyVersion=(l=this[A])===null||l===void 0?void 0:l.keyVersion),c.send(JSON.stringify(o))}))}on(e,t,n){this.getWebSocket(!1).then((s=>{this[N].has(e)||this[N].set(e,new Set);const a=this[N].get(e);if(e==="error"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t;this[V].push(i);const c=o=>{try{const r=o?.message||o?.data||o?.type||(typeof o=="string"?o:"WebSocket error occurred");i(new Error(r))}catch{i(new Error("WebSocket error occurred"))}};s.addEventListener("error",c),a.add({handler:i,wsListener:c})}if(e==="connect"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,c=()=>i();s.addEventListener("open",c),a.add({handler:i,wsListener:c})}if(e==="disconnect"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,c=()=>i();s.addEventListener("close",c),a.add({handler:i,wsListener:c})}const l=(i,c,o=!1)=>{const r=o?i.keyVersion:i.payload.keyVersion;if(r===void 0)return c(i.payload);if(r>-1){if(!this.getEncryptionHandler)return this[V].forEach((h=>h(new Error("Encrypted data, but no passphrase or getEncryptionHandler configured!"))));if(!this.encryptionHandler)return this[V].forEach((h=>h(new Error("Encrypted data, but getEncryptionSettings() not called!"))));let d=i.payload.value;o&&(d=i.payload),this.getEncryptionHandlerForKeyVersion(r).then((h=>h?.decrypt(d))).then((h=>{o?i.payload=JSON.parse(h):i.payload.value=JSON.parse(h),c(i.payload)})).catch((h=>{this[V].forEach((u=>u(h)))}))}};if(e==="message"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,c=o=>{const r=JSON.parse(o.data);r.event==="message"&&l(r,i,!0)};s.addEventListener("message",c),a.add({handler:i,wsListener:c})}if(e==="presence:join"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,c=o=>{const r=JSON.parse(o.data);r.event==="presence:join"&&l(r,(d=>{i({connectionId:r?.connectionId,joinedAt:r?.joinedAt,data:d})}),!0)};s.addEventListener("message",c),a.add({handler:i,wsListener:c})}if(e==="presence:leave"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,c=o=>{const r=JSON.parse(o.data);r.event==="presence:leave"&&l(r,(d=>{i({connectionId:r?.connectionId,data:d})}),!0)};s.addEventListener("message",c),a.add({handler:i,wsListener:c})}if(e==="setItem")if(n===void 0){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,c=o=>{const r=JSON.parse(o.data);r.event==="setItem"&&l(r,i)};s.addEventListener("message",c),a.add({handler:i,wsListener:c})}else{if(typeof n!="function")throw new Error("No event handler defined!");const i=n,c=t,o=r=>{const d=JSON.parse(r.data);d.event==="setItem"&&d.payload.prop===c&&l(d,i)};s.addEventListener("message",o),a.add({handler:i,wsListener:o,itemName:c})}if(e==="removeItem")if(n===void 0){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,c=o=>{const r=JSON.parse(o.data);r.event==="removeItem"&&i(r.payload)};s.addEventListener("message",c),a.add({handler:i,wsListener:c})}else{if(typeof n!="function")throw new Error("No event handler defined!");const i=n,c=t,o=r=>{const d=JSON.parse(r.data);d.event==="removeItem"&&d.payload.prop===c&&i(d.payload)};s.addEventListener("message",o),a.add({handler:i,wsListener:o,itemName:c})}}))}off(e,t,n){const s=this[N].get(e);if(s){if(e==="error"){if(typeof t!="function")throw new Error("No event handler defined!");const a=t,l=this[V].indexOf(a);l>-1&&this[V].splice(l,1);for(const i of s)if(i.handler===a){this[b]&&i.wsListener&&this[b].removeEventListener("error",i.wsListener),s.delete(i);break}}else{if(!this[b])return;const a=this[b];let l,i;if(n===void 0){if(typeof t!="function")throw new Error("No event handler defined!");l=t}else{if(typeof n!="function")throw new Error("No event handler defined!");l=n,i=t}for(const c of s){const o=c.handler===l,r=i===void 0||c.itemName===i;if(o&&r){if(c.wsListener){const d=e==="connect"?"open":e==="disconnect"?"close":e==="error"?"error":"message";a.removeEventListener(d,c.wsListener)}s.delete(c);break}}}s.size===0&&this[N].delete(e),this[N].size===0&&this[V].length===0&&this.disconnect()}}connect(){return v(this,void 0,void 0,(function*(){this[b]||(yield this.getWebSocket())}))}disconnect(){return v(this,void 0,void 0,(function*(){this.autoReconnect=!1,this[b]&&(this.hasJoined&&(yield this.leave()),this[b].close(),delete this[b],this[N].clear(),this[V].length=0)}))}getWebSocket(){return v(this,arguments,void 0,(function*(e=!0){if(!this[m].accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken),this[b])return this[b];this.autoReconnect=this.configuredAutoReconnect;const t=U.basePath.replace("http","ws"),n=this[m].apiKey&&this[m].apiSecret?`Basic ${btoa(`${this[m].apiKey}:${this[m].apiSecret}`)}`:void 0,s=this[m].accessToken?`Bearer ${this[m].accessToken}`:void 0,a={auth:this[m].accessToken?s:n};this.idSignature&&(a.idSignature=this.idSignature,this.idSignatureKeyVersion!==void 0&&(a.idSignatureKeyVersion=this.idSignatureKeyVersion));const l=new URLSearchParams(a),i=this[b]=new WebSocket(`${t}/project/${this[m].projectId}/ws/${this.class}/${this.id}?${l}`);this.logger.log("info","initializing WebSocket connection...");let c;i.addEventListener("message",(r=>{let d;try{d=typeof r.data=="string"?JSON.parse(r.data):void 0}catch{d=void 0}if(!d||typeof d!="object")return;const h=d.event;if(h){if(h!=="pong"){if(h!=="connected"&&h!=="resume:ack"||!d.connectionId){if(h==="error"){const u=d.payload;if(typeof u=="string"&&u.toLowerCase().includes("invalid resume")&&(this.logger.log("warn","server signalled invalid resume token â€” clearing saved connectionId"),this.connectionId=void 0,typeof r.stopImmediatePropagation=="function"))try{r.stopImmediatePropagation()}catch{}}}else if(this.connectionId=d.connectionId,typeof r.stopImmediatePropagation=="function")try{r.stopImmediatePropagation()}catch{}}else if(this.logger.log("debug","received pong"),this.clearPongTimer(),typeof r.stopImmediatePropagation=="function")try{r.stopImmediatePropagation()}catch{}}}));const o=new Promise((r=>{c=r}));return i.addEventListener("open",(()=>{if(this.isConnected=!0,this.reconnectAttempts=0,this.connectionId)try{i.send(JSON.stringify({event:"resume",connectionId:this.connectionId}))}catch{}this.startHeartbeat(),typeof c=="function"&&c(i)}),{once:!0}),i.addEventListener("close",(r=>{this.isConnected=!1,this.stopHeartbeat()}),{once:!0}),i.addEventListener("close",(r=>{r?.code===1008&&(this.logger.log("warn","WebSocket closed with 1008 during reconnection"),this.connectionId=void 0),r?.reason&&r?.reason.indexOf("TierLimitExceeded")>-1&&(this.autoReconnect=!1,this.logger.log("error",r.reason),this[V].forEach((u=>u(new Error(r.reason))))),delete this[b];const d=this.hasJoined,h=this.lastJoinData;if(this.hasJoined&&(this.hasJoined=!1),this.autoReconnect){const u=()=>v(this,void 0,void 0,(function*(){const w=Math.min(this.reconnectBaseDelay*Math.pow(2,this.reconnectAttempts),this.reconnectMaxDelay);setTimeout((()=>v(this,void 0,void 0,(function*(){let y;this.reconnectAttempts++,this.logger.log("warn",`${this.reconnectAttempts}. reconnection attempt...`);try{delete this[b],y=yield this.getWebSocket(!1)}catch(E){return this.logger.log("error",E?.message||E?.name||E?.type||E),void u()}const x=()=>v(this,void 0,void 0,(function*(){if(this.reconnectAttempts=0,!this[b])return;const E=this[b];for(const[I,D]of this[N])for(const $ of D){let T;I==="connect"?(T=()=>$.handler(),E.addEventListener("open",T)):I==="disconnect"?(T=()=>$.handler(),E.addEventListener("close",T)):I==="error"?(T=S=>{try{const f=S?.message||S?.data||S?.type||(typeof S=="string"?S:"WebSocket error occurred");$.handler(new Error(f))}catch{$.handler(new Error("WebSocket error occurred"))}},E.addEventListener("error",T)):I==="message"?(T=S=>{let f;try{f=typeof S.data=="string"?JSON.parse(S.data):void 0}catch{f=void 0}f&&f.event==="message"&&$.handler(f.payload)},E.addEventListener("message",T)):I==="presence:join"?(T=S=>{let f;try{f=typeof S.data=="string"?JSON.parse(S.data):void 0}catch{f=void 0}f&&f.event==="presence:join"&&$.handler(f.payload)},E.addEventListener("message",T)):I==="presence:leave"?(T=S=>{let f;try{f=typeof S.data=="string"?JSON.parse(S.data):void 0}catch{f=void 0}f&&f.event==="presence:leave"&&$.handler(f.payload)},E.addEventListener("message",T)):I==="setItem"?(T=S=>{let f;try{f=typeof S.data=="string"?JSON.parse(S.data):void 0}catch{f=void 0}f&&f.event==="setItem"&&($.itemName&&f.payload.prop!==$.itemName||$.handler(f.payload))},E.addEventListener("message",T)):I==="removeItem"&&(T=S=>{let f;try{f=typeof S.data=="string"?JSON.parse(S.data):void 0}catch{f=void 0}f&&f.event==="removeItem"&&($.itemName&&f.payload.prop!==$.itemName||$.handler(f.payload))},E.addEventListener("message",T)),T&&($.wsListener=T)}const _=this[N].get("connect");if(_)for(const I of _)try{I.handler()}catch(D){this.logger.log("error",D)}d&&h&&(yield this.join(h))})),k=()=>{y?.removeEventListener("open",j),y?.removeEventListener("close",K),y?.removeEventListener("error",L)},j=()=>v(this,void 0,void 0,(function*(){yield x(),k()})),K=()=>{k(),u()},L=E=>{this.logger.log("error",E?.message||E?.name||E?.type||E),k(),u()};y.addEventListener("open",j,{once:!0}),y.addEventListener("close",K,{once:!0}),y.addEventListener("error",L,{once:!0}),y.readyState!==WebSocket.CLOSING&&y.readyState!==WebSocket.CLOSED?y.readyState===WebSocket.OPEN&&(yield x(),k()):u()}))),w)}));u()}})),e?o:i}))}clearPongTimer(){this.pongTimer&&(clearTimeout(this.pongTimer),this.pongTimer=void 0)}startPongTimer(){this.clearPongTimer(),this.pongTimer=setTimeout((()=>{var e;this.logger.log("warn","pong timeout â€” closing socket to reconnect");try{(e=this[b])===null||e===void 0||e.close(1006,"pong timeout")}catch{}}),this.pongTimeout)}stopHeartbeat(){this.pingTimer&&(clearInterval(this.pingTimer),this.pingTimer=void 0),this.clearPongTimer()}startHeartbeat(){this.stopHeartbeat();const e=this[b];if(e&&e.readyState===WebSocket.OPEN)try{e.send(JSON.stringify({event:"ping"})),this.startPongTimer()}catch{}this.pingTimer=setInterval((()=>{const t=this[b];if(t&&t.readyState===WebSocket.OPEN)try{t.send(JSON.stringify({event:"ping"})),this.startPongTimer()}catch{}}),this.pingInterval)}join(e){return v(this,void 0,void 0,(function*(){var t,n;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");try{yield this.throttleManager.throttleOperation()}catch(i){throw this.logger.log("error",`Request throttled: ${i?.message}`),i}this.hasJoined=!0,this.lastJoinData=e;const s=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e)):e,a=yield this.getWebSocket(),l={event:"presence:join",payload:s};this[A]&&((t=this[A])===null||t===void 0?void 0:t.keyVersion)>-1&&(l.keyVersion=(n=this[A])===null||n===void 0?void 0:n.keyVersion),a.send(JSON.stringify(l))}))}leave(){return v(this,void 0,void 0,(function*(){var e,t;if(!this.hasJoined)return;try{yield this.throttleManager.throttleOperation()}catch(a){throw this.logger.log("error",`Request throttled: ${a?.message}`),a}this.hasJoined=!1;const n=yield this.getWebSocket(),s={event:"presence:leave"};this[A]&&((e=this[A])===null||e===void 0?void 0:e.keyVersion)>-1&&(s.keyVersion=(t=this[A])===null||t===void 0?void 0:t.keyVersion),n.send(JSON.stringify(s))}))}getJoinedConnections(){return v(this,void 0,void 0,(function*(){var e;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let t;try{t=yield this.request("GET",`/presence-list/${this.class}/${this.id}`)}catch(s){if(!s||((e=s?.cause)===null||e===void 0?void 0:e.name)!=="ConflictError")throw s;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),t=yield this.request("GET",`/presence-list/${this.class}/${this.id}`)}const n=t;return Promise.all(n?.map((s=>v(this,void 0,void 0,(function*(){const a=yield this.getEncryptionHandlerForKeyVersion(s.keyVersion),l=a?JSON.parse(yield a.decrypt(s.data)):s.data;return{connectionId:s.connectionId,joinedAt:s.joinedAt,data:l}}))))||[])}))}}Q=N;class ye extends U{constructor(e,t){typeof t=="string"?super(e,t):(super(e,t),t?.ttl&&(this.ttl=t?.ttl))}setItem(e,t,n){return v(this,void 0,void 0,(function*(){var s,a;if(!e)throw new Error("No name passed!");if(!t&&t!==0&&t!==""&&t!==!1)throw new Error("No value passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const l=n?.ttl||this.ttl,i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(t)):t;let c;try{c=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}`,{value:i,ttl:l,ifAbsent:n?.ifAbsent})}catch(r){if(!r||((s=r?.cause)===null||s===void 0?void 0:s.name)!=="ConflictError")throw r;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),c=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}`,{value:i,ttl:l,ifAbsent:n?.ifAbsent})}const o=c;return o&&{value:o?.value,expiresAt:o?.expiresAt,keyVersion:(a=o?.keyVersion)!==null&&a!==void 0?a:void 0,createdAt:o?.createdAt,updatedAt:o?.updatedAt}}))}setItems(e){return v(this,void 0,void 0,(function*(){var t,n;if(!e||Object.keys(e).length===0)throw new Error("No items passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");for(const l of Object.keys(e)){const i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e[l].value)):e[l].value;e[l].value=i,(n=e[l]).ttl||(n.ttl=this.ttl)}let s;try{s=yield this.request("POST",`/cache/${this.class}/${this.id}`,e)}catch(l){if(!l||((t=l?.cause)===null||t===void 0?void 0:t.name)!=="ConflictError")throw l;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),s=yield this.request("POST",`/cache/${this.class}/${this.id}`,e)}const a=s;return Object.keys(a).reduce(((l,i)=>{var c,o,r,d,h,u,w,y,x,k;return l[i]={value:(o=(c=a[i])===null||c===void 0?void 0:c.value)!==null&&o!==void 0?o:null,expiresAt:(d=(r=a[i])===null||r===void 0?void 0:r.expiresAt)!==null&&d!==void 0?d:0,keyVersion:(u=(h=a[i])===null||h===void 0?void 0:h.keyVersion)!==null&&u!==void 0?u:void 0,createdAt:(y=(w=a[i])===null||w===void 0?void 0:w.createdAt)!==null&&y!==void 0?y:0,updatedAt:(k=(x=a[i])===null||x===void 0?void 0:x.updatedAt)!==null&&k!==void 0?k:0},l}),{})}))}getItem(e){return v(this,void 0,void 0,(function*(){var t,n;if(!e)throw new Error("No name passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let s;try{s=yield this.request("GET",`/cache/${this.class}/${this.id}/${e}`)}catch(o){if(!o||((t=o?.cause)===null||t===void 0?void 0:t.name)!=="ConflictError")throw o;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),s=yield this.request("GET",`/cache/${this.class}/${this.id}/${e}`)}const a=s,l=a?.value;if(!l)return;const i=yield this.getEncryptionHandlerForKeyVersion(a.keyVersion),c=i?JSON.parse(yield i.decrypt(l)):l;return a?.keyVersion>-1&&a.keyVersion!==((n=this[A])===null||n===void 0?void 0:n.keyVersion)&&(this.autoUpdateOldEncryptedValues?(this.logger.log("info",`Item "${e}" has an old encryption and will be automatically updated now by setting it again.`),yield this.setItem(e,c,{ttl:a.expiresAt-Date.now()})):this.logger.log("warn",`Item "${e}" has an old encryption and can be updated by setting it again.`)),{value:c,expiresAt:a.expiresAt,keyVersion:a.keyVersion,createdAt:a.createdAt,updatedAt:a.updatedAt}}))}getItems(e){return v(this,void 0,void 0,(function*(){var t,n;if(!e||e.length===0)throw new Error("No names passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let s;try{s=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,e)}catch(o){if(!o||((t=o?.cause)===null||t===void 0?void 0:t.name)!=="ConflictError")throw o;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),s=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,e)}const a=s;if(Object.keys(a).length===0)return;const l={},i={};for(const o of Object.keys(a)){const r=a[o],d=r?.value;if(!d)continue;const h=yield this.getEncryptionHandlerForKeyVersion(r.keyVersion),u=h?JSON.parse(yield h.decrypt(d)):d;r?.keyVersion>-1&&r.keyVersion!==((n=this[A])===null||n===void 0?void 0:n.keyVersion)&&(l[o]=r),i[o]={value:u,expiresAt:r.expiresAt,keyVersion:r.keyVersion,createdAt:r.createdAt,updatedAt:r.updatedAt}}const c=Object.keys(l);if(c.length>0)if(this.autoUpdateOldEncryptedValues){this.logger.log("info",`These items "${c.join(",")}" have an old encryption and will be automatically updated now by setting them again.`);const o=c.reduce(((r,d)=>(r[d]={value:i[d].value,ttl:l[d].expiresAt-Date.now()},r)),{});yield this.setItems(o)}else this.logger.log("warn",`These items "${c.join(",")}" have an old encryption and can be updated by setting them again.`);return i}))}getAllItems(e){return v(this,void 0,void 0,(function*(){var t,n;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let s;try{s=yield this.request("GET",`/cache/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}catch(i){if(!i||((t=i?.cause)===null||t===void 0?void 0:t.name)!=="ConflictError")throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),s=yield this.request("GET",`/cache/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}const a=s;if(Object.keys(a).length===0)return;const l={};for(const i of Object.keys(a)){const c=a[i],o=c?.value;if(!o)continue;const r=yield this.getEncryptionHandlerForKeyVersion(c.keyVersion),d=r?JSON.parse(yield r.decrypt(o)):o;l[i]={value:d,expiresAt:c.expiresAt,keyVersion:(n=c.keyVersion)!==null&&n!==void 0?n:void 0,createdAt:c.createdAt,updatedAt:c.updatedAt}}return l}))}getAllKeys(e){return v(this,void 0,void 0,(function*(){return yield this.request("GET",`/cache-keys/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}))}removeItem(e){return v(this,void 0,void 0,(function*(){if(!e)throw new Error("No name passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}/${e}`)}))}removeItems(e){return v(this,void 0,void 0,(function*(){if(!e||e.length===0)throw new Error("No names passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}`,e)}))}incrementItem(e){return v(this,arguments,void 0,(function*(t,n=1,s){var a;if(!t)throw new Error("No name passed!");if(n==null)throw new Error("No value passed!");if(typeof n!="number")throw new Error("Value needs to be a number!");const l=s?.ttl||this.ttl,i=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}/increment`,{value:n,ttl:l});return{value:i?.value,expiresAt:i?.expiresAt,keyVersion:(a=i?.keyVersion)!==null&&a!==void 0?a:void 0,createdAt:i?.createdAt,updatedAt:i?.updatedAt}}))}decrementItem(e){return v(this,arguments,void 0,(function*(t,n=1,s){var a;if(!t)throw new Error("No name passed!");if(n==null)throw new Error("No value passed!");if(typeof n!="number")throw new Error("Value needs to be a number!");const l=s?.ttl||this.ttl,i=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}/decrement`,{value:n,ttl:l});return{value:i?.value,expiresAt:i?.expiresAt,keyVersion:(a=i?.keyVersion)!==null&&a!==void 0?a:void 0,createdAt:i?.createdAt,updatedAt:i?.updatedAt}}))}clear(){return v(this,void 0,void 0,(function*(){yield this.request("DELETE",`/cache/${this.class}/${this.id}`)}))}}const G={};function fe(p,e){return`${`${e.projectId}-${e.apiKey}`}-${p.class?`${p.class}-${p.id}`:`__undefined__-${p.id}`}`}const W=(p,e)=>{const t=e||re(),n=fe(p,t);if(G[n])return G[n];const s=new ye(t,p);return G[n]=s,s};function me(p,e,t){const[n,s]=O.useState(),[a,l]=O.useState(),[i,c]=O.useState(!0),o=W({...t?.instanceOptions,id:p},t?.credentials),r=t?.bind??!0;if(O.useEffect(()=>{if(!o)return;c(!0);try{(async function(h,u,w){let y;typeof u=="string"?(y=await h.getItem(u),w&&w({[`${u}`]:y})):(y=await h.getItems(u),w&&w(y))})(o,e,h=>{s(h),c(!1)})}catch(h){l(h),c(!1)}const d={};return r&&(Array.isArray(e)?e:[e]).forEach(h=>{const u=(w=>function(y){s(x=>({...x,[`${w}`]:y}))})(h);d[h]=u,o.on("setItem",h,u)}),()=>{r&&Object.keys(d).forEach(h=>{o.off("setItem",h,d[h])})}},[e]),typeof e=="string"){const d=async()=>{c(!0);try{const u=await o.getItem(e);return c(!1),u}catch(u){l(u),c(!1)}},h=u=>{u&&s(w=>({...w,[`${e}`]:u}))};return[o,n?n[e]:void 0,h,d,a,l,i]}return[o,n,s,async()=>{c(!0);try{const d=await o.getItems(e);return c(!1),d}catch(d){l(d),c(!1)}},a,l,i]}const we=(p,e,t)=>{const[n,s,a,,l,i,c]=me(p,e,t);return[s,async o=>{try{const r=await n.setItems(o);a({...s,...r})}catch(r){i(r)}},l,c]};function Z({style:p,children:e}){return g.jsx("div",{className:"vaultrice-card",style:p,children:e})}Z.__docgenInfo={description:`A styled card container for Vaultrice UI.

@param props - CardProps
@returns A React div element styled as a card.`,methods:[],displayName:"Card",props:{style:{required:!1,tsType:{name:"ReactCSSProperties",raw:"React.CSSProperties"},description:""},children:{required:!1,tsType:{name:"ReactReactNode",raw:"React.ReactNode"},description:""}}};function ee({percentage:p=0,style:e}){const[t,n]=O.useState(0);return O.useEffect(()=>{setTimeout(()=>{n(p)},1300)},[p]),g.jsx("div",{className:"vaultrice-meter-container",style:e,children:g.jsxs("div",{className:`vaultrice-meter-control ${t>100?"vaultrice-meter-control-error":t>90?"vaultrice-meter-control-warning":""}`,children:[g.jsx("div",{className:"vaultrice-meter-track",style:{width:t<100?"100%":`${100/(t/100)}%`}}),g.jsx("div",{className:"vaultrice-meter-state",style:{width:`${t}%`,borderRadius:t>=100?"14px":"14px 0 0 14px",opacity:t===0?0:1}})]})})}ee.__docgenInfo={description:`A visual meter bar for displaying percentage values.
Animates to the given percentage after mount/update.

@param props - MeterProps
@returns A React element representing the meter bar.`,methods:[],displayName:"Meter",props:{percentage:{required:!1,tsType:{name:"number"},description:"",defaultValue:{value:"0",computed:!1}},style:{required:!1,tsType:{name:"ReactCSSProperties",raw:"React.CSSProperties"},description:""}}};function te({onClick:p,disabled:e,style:t,children:n}){return g.jsx("button",{className:"vaultrice-button",style:t,type:"button",disabled:e,onClick:p,children:n})}te.__docgenInfo={description:`A styled button component for Vaultrice UI.

@param props - ButtonProps
@returns A React button element.`,methods:[],displayName:"Button",props:{style:{required:!1,tsType:{name:"ReactCSSProperties",raw:"React.CSSProperties"},description:""},children:{required:!1,tsType:{name:"ReactReactNode",raw:"React.ReactNode"},description:""},disabled:{required:!1,tsType:{name:"boolean"},description:""},onClick:{required:!1,tsType:{name:"ReactMouseEventHandler",raw:"React.MouseEventHandler<HTMLButtonElement>",elements:[{name:"HTMLButtonElement"}]},description:""}}};function Ee(p,e,t,n,s,a){const[l,i]=O.useState(),[c,o]=O.useState(!1),[r,d]=O.useState(!1),[h,u]=O.useState(!1);t||=e;const w=`${p}-user-${e}-voted`,y=`vaultrice-${p}-user-${t}-voted`,x=`${p}-user-${e}`,k=p,j=e?W({...n,id:x},a):void 0;return O.useEffect(()=>{const L=async()=>{e?await j?.getItem(w)&&d(!0):window.localStorage.getItem(y)&&d(!0),o(!0)};try{L()}catch(E){i(E)}},[w,j,e,t,y]),[c,h,r,async L=>{try{if(r)return;u(!0),await W({...s,id:k},a).incrementItem(`${k}-choices-${L}`),e?await j?.setItem(w,Date.now()):window.localStorage.setItem(y,Date.now().toString()),u(!1),d(!0)}catch(E){i(E)}},l]}const Se=({id:p,choices:e=[],choicesInstanceOptions:t,credentials:n,bind:s=!0})=>{const[a]=O.useState(e.map(o=>`${p}-choices-${o.id}`)),[l,,,i]=we(p,a,{credentials:n,instanceOptions:t,bind:s});if(!i&&!l)return g.jsxs("div",{className:"vaultrice-voting-result vaultrice-voting-expired",children:[g.jsxs("div",{className:"vaultrice-voting--result-label",children:[g.jsx("span",{className:"vaultrice-voting-expired-icon","aria-label":"Voting closed",role:"img",children:"ðŸ”’"}),g.jsx("label",{className:"vaultrice-voting-expired-label",children:"Voting closed"}),g.jsx("span",{className:"vaultrice-voting-result-label-tag",children:"Expired"})]}),g.jsx("p",{className:"vaultrice-voting-expired-text",children:"This voting has expired and is no longer accepting responses."})]});if(!l)return null;const c=Object.values(l).reduce((o,r)=>r?.value?o+r.value:o,0);return g.jsx("div",{className:"vaultrice-voting-results",children:e.map(o=>{const r=l[`${p}-choices-${o.id}`],d=r?.value?r.value/c*100:0;return g.jsxs("div",{className:"vaultrice-voting-result",children:[g.jsxs("div",{className:"vaultrice-voting--result-label",children:[g.jsx("label",{children:o.label}),g.jsx("span",{className:"vaultrice-voting-result-label-tag",children:r?.value||0})]}),g.jsx(ee,{percentage:d})]},o.id)})})},ie=({id:p,title:e,description:t,voteLabel:n="vote",choices:s=[],choicesInstanceOptions:a,userId:l,userIdForLocalStorage:i,userInstanceOptions:c,credentials:o,bind:r=!0})=>{const[d,h]=O.useState(s?.[0]?.id),[u,w,y,x]=Ee(p,l,i,c,a,o);return u?g.jsxs(Z,{children:[!!e&&g.jsx("h3",{className:"vaultrice-voting-title",children:e}),!!t&&g.jsx("p",{className:"vaultrice-voting-description",children:t}),!!y&&g.jsx(Se,{id:p,choices:s,choicesInstanceOptions:a,credentials:o,bind:r}),!y&&g.jsxs(g.Fragment,{children:[g.jsx("div",{className:"vaultrice-voting-choices",children:s.map(k=>g.jsxs("div",{className:"vaultrice-voting-choice",onClick:j=>{j.target.tagName!=="INPUT"&&h(k.id)},style:{cursor:"pointer"},children:[g.jsx("input",{type:"radio",name:k.id,value:k.id,checked:k.id===d,onChange:()=>{h(k.id)},style:{cursor:"pointer"}}),g.jsx("label",{htmlFor:k.id,style:{cursor:"pointer"},children:k.label})]},k.id))}),g.jsx(te,{onClick:()=>{x(d)},disabled:w,children:w?"...voting":n})]}),g.jsxs("div",{className:"vaultrice-voting-disclaimer",children:["Powered by ",g.jsx("a",{href:"https://www.vaultrice.com",target:"_blank",rel:"noreferrer",children:"vaultrice.com"})," get yours ",g.jsx("a",{href:"https://www.vaultrice.app/register",target:"_bland",children:"for free!"})]})]}):null};ie.__docgenInfo={description:`Voting component for Vaultrice UI.

Renders a voting form with selectable choices, handles voting logic,
and displays results after voting.

@param props - VotingProps
@returns A React element for voting.`,methods:[],displayName:"Voting",props:{id:{required:!0,tsType:{name:"string"},description:"Unique identifier for the voting instance."},title:{required:!1,tsType:{name:"string"},description:"Optional headline for the voting."},description:{required:!1,tsType:{name:"string"},description:"Optional description for the voting."},voteLabel:{required:!1,tsType:{name:"string"},description:`Optional label for the voting button.
@default 'vote'`,defaultValue:{value:"'vote'",computed:!1}},choices:{required:!1,tsType:{name:"Array",elements:[{name:"signature",type:"object",raw:`{
  /**
   * Unique identifier for the choice.
   */
  id: string,
  /**
   * Display label for the choice.
   */
  label: string | ReactNode
}`,signature:{properties:[{key:"id",value:{name:"string",required:!0},description:"Unique identifier for the choice."},{key:"label",value:{name:"union",raw:"string | ReactNode",elements:[{name:"string"},{name:"ReactNode"}],required:!0},description:"Display label for the choice."}]}}],raw:"Array<ChoiceOption>"},description:"Array of available choices for the voting.",defaultValue:{value:"[]",computed:!1}},choicesInstanceOptions:{required:!1,tsType:{name:"InstanceOptions"},description:"Optional instance options for managing choices storage."},userId:{required:!1,tsType:{name:"string"},description:"Optional user identifier. If provided, voting status is stored in Vaultrice; otherwise, localStorage is used."},userInstanceOptions:{required:!1,tsType:{name:"InstanceOptions"},description:"Optional instance options for managing user storage."},credentials:{required:!1,tsType:{name:"Credentials"},description:"Optional credentials for accessing Vaultrice SDK, if not using vaultrice.init."},bind:{required:!1,tsType:{name:"boolean"},description:`Whether to bind to changes.
@default true`,defaultValue:{value:"true",computed:!1}},userIdForLocalStorage:{required:!1,tsType:{name:"string"},description:`Optional user identifier for localStorage.
If not provided it wull use the passed userId or undefined.
@default 'undefined'`}}};const $e={title:"Vaultrice/Voting",component:ie,parameters:{layout:"centered"},tags:["autodocs"],argTypes:{credentials:{control:!1}},args:{}},R={args:{id:"voting1",title:"Vote for our latest feature proposal",description:"Every voice counts to get this component like you want it.",choices:[{id:"op1",label:"Create a render prop."},{id:"op2",label:"Have a dark theme."},{id:"op3",label:g.jsxs(g.Fragment,{children:["I'm already ",g.jsx("a",{href:"https://www.vaultrice.com/",target:"_blank",rel:"noreferrer",children:"happy"})," with what ",g.jsx("strong",{children:"I got"}),"."]})}],credentials:{projectId:"253c8eeb-dcdf-4d67-8557-a7a8b92228be",apiKey:"08ee33b7-9e85-47b8-a164-87f0afba70fc",apiSecret:"27b20eee-3171-4727-8280-17ef62556c9f"}}};R.parameters={...R.parameters,docs:{...R.parameters?.docs,source:{originalSource:`{
  args: {
    id: 'voting1',
    title: 'Vote for our latest feature proposal',
    description: 'Every voice counts to get this component like you want it.',
    choices: [{
      id: 'op1',
      label: 'Create a render prop.'
    }, {
      id: 'op2',
      label: 'Have a dark theme.'
    }, {
      id: 'op3',
      label: <>I'm already <a href='https://www.vaultrice.com/' target='_blank' rel='noreferrer'>happy</a> with what <strong>I got</strong>.</>
    }],
    credentials: {
      projectId: import.meta.env.VITE_VAULTRICE_PROJECTID,
      apiKey: import.meta.env.VITE_VAULTRICE_APIKEY,
      apiSecret: import.meta.env.VITE_VAULTRICE_APISECRET
    }
  }
}`,...R.parameters?.docs?.source}}};const Oe=["Primary"];export{R as Primary,Oe as __namedExportsOrder,$e as default};
