import{j as g}from"./jsx-runtime-D_zvdyIk.js";import{r as C}from"./iframe-B2Q1yKdt.js";import"./preload-helper-D9Z9MdNV.js";let oe;const re=()=>oe;function v(p,e,t,n){return new(t||(t=Promise))((function(o,r){function s(l){try{d(n.next(l))}catch(a){r(a)}}function i(l){try{d(n.throw(l))}catch(a){r(a)}}function d(l){var a;l.done?o(l.value):(a=l.value,a instanceof t?a:new t((function(c){c(a)}))).then(s,i)}d((n=n.apply(p,e||[])).next())}))}const z="NON_LOCAL_STORAGE_LOCAL_ID",se=(p,e)=>typeof window<"u"&&window.localStorage?window.localStorage.getItem(`${z}:${p}:${e}`):null,ae=(p,e,t)=>{typeof window<"u"&&window.localStorage&&window.localStorage.setItem(`${z}:${p}:${e}`,t)};function le(p,e,t){return v(this,arguments,void 0,(function*(n,o,r,s={iterations:1e5,hash:"SHA-512",derivedKeyType:{name:"AES-GCM",length:256}}){const i=new TextEncoder,d=yield crypto.subtle.importKey("raw",i.encode(n+":"+o),"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:s?.iterations||1e5,hash:s?.hash||"SHA-512"},d,s?.derivedKeyType||{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}))}function de(p,e){return v(this,arguments,void 0,(function*(t,n,o={algorithm:"AES-GCM"}){const r=new TextEncoder,s=crypto.getRandomValues(new Uint8Array(12)),i=yield crypto.subtle.encrypt({name:o?.algorithm||"AES-GCM",iv:s},t,r.encode(n));return JSON.stringify({iv:btoa(String.fromCharCode(...s)),data:btoa(String.fromCharCode(...new Uint8Array(i)))})}))}function ce(p,e){return v(this,arguments,void 0,(function*(t,n,o={algorithm:"AES-GCM"}){const r=JSON.parse(n),s=new TextDecoder,i=Uint8Array.from(atob(r.iv),(a=>a.charCodeAt(0))),d=Uint8Array.from(atob(r.data),(a=>a.charCodeAt(0))),l=yield crypto.subtle.decrypt({name:o?.algorithm||"AES-GCM",iv:i},t,d);return s.decode(l)}))}let X;X=typeof crypto<"u"&&typeof crypto.randomUUID=="function"?()=>crypto.randomUUID():()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(p=>{const e=16*Math.random()|0;return(p==="x"?e:3&e|8).toString(16)}));var F=X;const B=["error","warn","info","debug"];let ue=class{constructor(e){this.level=e}log(e,t){B.indexOf(this.level)<B.indexOf(e)||console[e](t)}};var Y=(p="warn")=>new ue(p);function W(p){let e=p.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4!=0;)e+="=";return atob(e)}function he(p){if(typeof p!="string")throw new Error("JWT must be a string");const e=p.split(".");if(e.length!==3)throw new Error("JWT should consist of three parts: header.payload.signature");const[t,n,o]=e,r=W(t);let s;try{s=JSON.parse(r)}catch(l){throw new Error("Invalid JWT header JSON: "+l.message)}const i=W(n);let d;try{d=JSON.parse(i)}catch(l){throw new Error("Invalid JWT payload JSON: "+l.message)}return{header:s,payload:d,signatureHex:(function(l){let a="";for(let c=0;c<l.length;c++)a+=l.charCodeAt(c).toString(16).padStart(2,"0");return a})(W(o))}}const m=Symbol("vaultrice/credentials"),N=Symbol("vaultrice/encryptionSettings"),P=Symbol("vaultrice/previousEncryptionSettings"),L=Symbol("vaultrice/errorHandlers"),V=Symbol("vaultrice/ws"),H=Symbol("vaultrice/eventHandlers"),K=Symbol("vaultrice/accessTokenExpiringHandlers"),pe={enabled:!0,maxOperations:100,windowMs:6e4,operationDelay:0};let ve=class{constructor(e){this.operationHistory=[],this.lastOperationTime=0,this.operationConfig=Object.assign(Object.assign({},pe),e||{})}updateConfig(e){this.operationConfig=Object.assign(Object.assign({},this.operationConfig),e)}cleanupHistory(e,t){const n=Date.now()-t,o=e.findIndex((r=>r.timestamp>n));o>0?e.splice(0,o):o===-1&&(e.length=0)}isAllowed(e,t,n){return this.cleanupHistory(e,n),e.length<t}calculateDelay(e,t){if(t===0)return 0;const n=Date.now()-e;return Math.max(0,t-n)}throttleOperation(){return v(this,void 0,void 0,(function*(){if(!this.operationConfig.enabled)return;if(!this.isAllowed(this.operationHistory,this.operationConfig.maxOperations,this.operationConfig.windowMs))throw new Error(`Operation rate limit exceeded. Maximum ${this.operationConfig.maxOperations} operations per ${this.operationConfig.windowMs}ms allowed.`);const e=this.calculateDelay(this.lastOperationTime,this.operationConfig.operationDelay);var t;e>0&&(yield(t=e,new Promise((o=>setTimeout(o,t)))));const n=Date.now();this.operationHistory.push({timestamp:n}),this.lastOperationTime=n}))}getOperationStatus(){return this.cleanupHistory(this.operationHistory,this.operationConfig.windowMs),{enabled:this.operationConfig.enabled,currentCount:this.operationHistory.length,maxOperations:this.operationConfig.maxOperations,windowMs:this.operationConfig.windowMs,remaining:Math.max(0,this.operationConfig.maxOperations-this.operationHistory.length)}}reset(){this.operationHistory.length=0,this.lastOperationTime=0}};var Q;function ge(p,e){return se(p,e)||`${F()}-${F()}`}const R="_undefined_";class q{constructor(e,t={class:R,autoUpdateOldEncryptedValues:!0,logLevel:"warn"}){this.class=R,this[Q]=[];let n={class:R,logLevel:"warn"};if(typeof t=="string"?(this.id=t,n={class:R,logLevel:"warn"}):(this.id=t.id||ge(e.projectId,t.class||R),n=t),this.logger=Y(n.logLevel),!e||typeof e!="object"||typeof e.projectId!="string")throw new Error("Invalid credentials!");const o=typeof e.apiKey=="string"&&typeof e.apiSecret=="string",r=typeof e.accessToken=="string",s=typeof e.getAccessToken=="function",i=[o,s].filter(Boolean).length,d=r&&!s;if(i===0&&!d)throw new Error("Invalid credentials! Must provide one of: (apiKey + apiSecret), accessToken, or getAccessToken function");if(i>1||d&&i>0)throw new Error("Invalid credentials! Provide only one primary authentication method. You can combine getAccessToken with an initial accessToken for performance.");if((e.apiKey||e.apiSecret)&&!o)throw new Error("Invalid credentials! Both apiKey and apiSecret are required when using direct authentication");if(this.throttleManager=new ve(n.throttling),typeof t=="string"||t?.id||ae(e.projectId,t.class||R,this.id),this[m]=Object.assign({},e),typeof this[m].apiKey=="string"||typeof this[m].apiSecret=="string"||typeof this[m].accessToken!="string"&&!e.getAccessToken||(delete this[m].apiKey,delete this[m].apiSecret),e.getAccessToken&&(this.getAccessTokenFn=e.getAccessToken,delete this[m].getAccessToken),this.class=n.class||R,n.passphrase&&n.getEncryptionHandler)throw new Error("Either define a passphrase or a getEncryptionHandler, but not both!");if(n.getEncryptionHandler&&(this.getEncryptionHandler=n.getEncryptionHandler),n.passphrase&&(this.getEncryptionHandler=l=>v(this,void 0,void 0,(function*(){var a,c,u,h;const k=yield le(n.passphrase,this.id,l.salt,n.keyDerivationOptions),f=!((c=(a=n.keyDerivationOptions)===null||a===void 0?void 0:a.derivedKeyType)===null||c===void 0)&&c.name?{algorithm:(h=(u=n.keyDerivationOptions)===null||u===void 0?void 0:u.derivedKeyType)===null||h===void 0?void 0:h.name}:void 0;return{encrypt:b=>de(k,b,f),decrypt:b=>ce(k,b,f)}}))),n.autoUpdateOldEncryptedValues===void 0&&(n.autoUpdateOldEncryptedValues=!0),this.autoUpdateOldEncryptedValues=n.autoUpdateOldEncryptedValues,n.idSignature&&(this.idSignature=n.idSignature),this.idSignature&&(this.idSignatureKeyVersion=n.idSignatureKeyVersion),s)if(r){this.logger.log("debug","Using token provider with initial access token");try{this.useAccessTokenAndRememberToAcquireTheNext(this[m].accessToken)}catch{this.logger.log("warn","Initial access token is invalid, acquiring new token"),this[m].accessToken=void 0,this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}))}}else this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}));else r||(this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0})))}static executeWithRetry(e,t,n){return v(this,arguments,void 0,(function*(o,r,s,i={}){var d,l,a,c;const{maxRetries:u=3,initialDelay:h=100,maxDelay:k=2e3,backoffMultiplier:f=2}=i;let b,A=0;for(;A<=u;)try{return yield o()}catch(E){b=E;let x=!1,O="";const w=["Please try again in a moment","Please retry","Service temporarily unavailable","temporarily unavailable","try again later"];if(E&&typeof E=="object"){O=E.message||E.toString();const I=(d=E?.cause)===null||d===void 0?void 0:d.code;I&&I.indexOf("retry")>-1?x=!0:O&&(x=w.some((S=>O.toLowerCase().includes(S.toLowerCase()))))}else typeof E=="string"?(O=E,x=w.some((I=>O.toLowerCase().includes(I.toLowerCase())))):(x=E?.name==="TypeError"||((l=E?.message)===null||l===void 0?void 0:l.includes("fetch"))||((a=E?.message)===null||a===void 0?void 0:a.includes("network"))||((c=E?.message)===null||c===void 0?void 0:c.includes("timeout")),O=E?.message||"Unknown error");if(x&&A<u){s&&s.log("warn",`${r} failed (attempt ${A+1}/${u+1}): ${O}. Retrying...`),A++;const I=Math.min(h*Math.pow(f,A-1),k),S=I+Math.random()*(.1*I);s&&s.log("debug",`Waiting ${Math.round(S)}ms before retry attempt ${A+1}`),yield new Promise((J=>setTimeout(J,S)));continue}throw E}throw b}))}static retrieveAccessToken(e,t,n,o){return v(this,void 0,void 0,(function*(){if(typeof e!="string"||!e)throw new Error("projectId not valid!");if(typeof t!="string"||!t)throw new Error("apiKey not valid!");if(typeof n!="string"||!n)throw new Error("apiSecret not valid!");const r={Authorization:`Basic ${btoa(`${t}:${n}`)}`};return typeof o?.origin=="string"&&o?.origin.length>0&&(r.Origin=o.origin),q.executeWithRetry((()=>v(this,void 0,void 0,(function*(){var s;const i=yield fetch(`${q.basePath}/project/${e}/auth/token`,{method:"GET",headers:r}),d=i.headers.get("content-type");let l;if(d)try{d.indexOf("text/plain")===0?l=yield i.text():d.indexOf("application/json")===0&&(l=yield i.json())}catch{l=`${i.status} - ${i.statusText}`}if(!i.ok){if(i.status===403&&l&&((s=l?.cause)===null||s===void 0?void 0:s.code)==="authorizationError.origin.server.notFound"&&(l.message='Failed to retrieve access token: access denied. This is due to an API key origin restriction. If minting a token from a backend for use in a browser, pass the browser-origin when calling retrieveAccessToken() e.g. NonLocalStorage.retrieveAccessToken("projectId", "apiKey", "apiSecret", { origin: req.headers.origin }).'),typeof l=="string")throw new Error(l);if(l)throw l;if(i.status!==404)throw new Error(`${i.status} - ${i.statusText}`)}return l}))),"Token retrieval",Y("warn"))}))}useAccessTokenAndRememberToAcquireTheNext(e){if(!e)throw new Error("No accessToken!");const t=this.useAccessToken(e),n=Math.max(t-12e4,1e3);this.logger.log("debug",`Scheduling next token refresh in ${n}ms`),setTimeout((()=>{this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}))}),n)}acquireAccessToken(){return v(this,void 0,void 0,(function*(){try{let e;if(this.getAccessTokenFn){if(this.logger.log("debug","Acquiring access token via custom provider"),e=yield this.getAccessTokenFn(),typeof e!="string"||!e)throw new Error("getAccessToken function must return a non-empty string")}else{if(!this[m].apiKey||!this[m].apiSecret)throw new Error("No authentication method available for token acquisition");this.logger.log("debug","Acquiring access token via API key/secret"),e=yield q.retrieveAccessToken(this[m].projectId,this[m].apiKey,this[m].apiSecret)}this.useAccessTokenAndRememberToAcquireTheNext(e)}catch(e){throw this.logger.log("error",`Access token acquisition failed: ${e?.message||e?.name||e?.type||e}`),e}}))}useAccessToken(e){if(typeof e!="string"||!e)throw new Error("accessToken not valid!");const t=he(e);this[m].accessToken=e;const n=t.payload.exp-Date.now();if(n-12e4<0)throw new Error("accessToken not valid anymore");return setTimeout((()=>{this[K].forEach((o=>o()))}),Math.max(n-12e4,0)),n}onAccessTokenExpiring(e){this[K].push(e)}offAccessTokenExpiring(e){const t=this[K].indexOf(e);t!==-1&&this[K].splice(t,1)}getEncryptionHandlerForKeyVersion(e){return v(this,void 0,void 0,(function*(){var t,n,o,r;if(e>-1&&(e!==((t=this[N])===null||t===void 0?void 0:t.keyVersion)&&(this[P]&&this[P].length!==0||(yield this.getEncryptionSettings())),e!==((n=this[N])===null||n===void 0?void 0:n.keyVersion))){if(!this[P]||this[P].length===0)throw new Error(`Wrong keyVersion! Found ${e} but you're using ${(o=this[N])===null||o===void 0?void 0:o.keyVersion}`);let s=this[P].find((i=>i.keyVersion===e));if(s||(yield this.getEncryptionSettings()),s=(this[P]||[]).find((i=>i.keyVersion===e)),!s)throw new Error(`Wrong keyVersion! Found ${e} but you're using ${(r=this[N])===null||r===void 0?void 0:r.keyVersion}`);return this.getEncryptionHandler?this.getEncryptionHandler(s):void 0}return this.encryptionHandler}))}handleEncryptionSettings(e){return v(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No getEncryptionHandler defined!");this[N]=e.encryptionSettings,this[P]=e.previousEncryptionSettings,this.encryptionHandler=yield this.getEncryptionHandler(e.encryptionSettings)}))}prepareEncryptionSettings(e){var t,n,o;return{encryptionSettings:{salt:Uint8Array.from(atob((t=e?.encryptionSettings)===null||t===void 0?void 0:t.salt),(r=>r.charCodeAt(0))),keyVersion:(n=e?.encryptionSettings)===null||n===void 0?void 0:n.keyVersion,createdAt:(o=e?.encryptionSettings)===null||o===void 0?void 0:o.createdAt},previousEncryptionSettings:(e?.previousEncryptionSettings||[]).map((r=>({salt:Uint8Array.from(atob(r?.salt),(s=>s.charCodeAt(0))),keyVersion:r?.keyVersion,createdAt:r?.createdAt})))}}getEncryptionSettings(e){return v(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const t=yield this.request("POST",`/cache-encryption/${this.class}/${this.id}`,e&&e>0?{saltLength:e}:{}),n=this.prepareEncryptionSettings(t);return yield this.handleEncryptionSettings(n),n}))}rotateEncryption(e){return v(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const t=yield this.request("POST",`/cache-encryption-rotate/${this.class}/${this.id}`,e&&e>0?{saltLength:e}:{}),n=this.prepareEncryptionSettings(t);return yield this.handleEncryptionSettings(n),n}))}request(e,t,n){return v(this,void 0,void 0,(function*(){!this[m].accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken);try{yield this.throttleManager.throttleOperation()}catch(o){throw this.logger.log("error",`Request throttled: ${o?.message}`),o}return q.executeWithRetry((()=>v(this,void 0,void 0,(function*(){var o;const r=this[m].apiKey&&this[m].apiSecret?`Basic ${btoa(`${this[m].apiKey}:${this[m].apiSecret}`)}`:void 0,s=this[m].accessToken?`Bearer ${this[m].accessToken}`:void 0;let i=this[m].accessToken?s:r;if(t==="/auth/token"&&(i=r),!i)throw new Error("No authentication option provided! (apiKey + apiSecret or accessToken)");const d={Authorization:i},l=typeof n=="string",a=(o=this[N])===null||o===void 0?void 0:o.keyVersion;a!==void 0&&a>-1&&(d["X-Enc-KV"]=a.toString()),this.idSignature&&(d["X-Id-Sig"]=this.idSignature,this.idSignatureKeyVersion!==void 0&&(d["X-Id-Sig-KV"]=this.idSignatureKeyVersion.toString())),n&&(d["Content-Type"]=l?"text/plain":"application/json");const c=yield fetch(`${q.basePath}/project/${this[m].projectId}${t}`,{method:e,headers:d,body:n?l?n:JSON.stringify(n):void 0}),u=c.headers.get("content-type");let h;if(u)try{u.indexOf("text/plain")===0?h=yield c.text():u.indexOf("application/json")===0&&(h=yield c.json())}catch{h=`${c.status} - ${c.statusText}`}if(!c.ok){if(typeof h=="string")throw new Error(h);if(h)throw h;if(c.status!==404)throw new Error(`${c.status} - ${c.statusText}`)}return h}))),"API request",this.logger)}))}}Q=K,q.basePath="https://api.vaultrice.app";var Z;class _ extends q{constructor(e,t){var n,o,r,s,i,d,l,a,c,u;super(e,t),this[Z]=new Map,this.reconnectAttempts=0,this.reconnectBaseDelay=1e3,this.reconnectMaxDelay=6e4,this.isConnected=!1,this.pingInterval=2e4,this.pongTimeout=1e4,this.hasJoined=!1,this[L]=[],this[H]=new Map;const h=typeof t=="object"?t:{};this.configuredAutoReconnect=(o=(n=h.connectionSettings)===null||n===void 0?void 0:n.autoReconnect)===null||o===void 0||o,this.autoReconnect=this.configuredAutoReconnect,this.reconnectBaseDelay=(s=(r=h.connectionSettings)===null||r===void 0?void 0:r.reconnectBaseDelay)!==null&&s!==void 0?s:1e3,this.reconnectMaxDelay=(d=(i=h.connectionSettings)===null||i===void 0?void 0:i.reconnectMaxDelay)!==null&&d!==void 0?d:3e4,this.pingInterval=(a=(l=h.connectionSettings)===null||l===void 0?void 0:l.pingInterval)!==null&&a!==void 0?a:2e4,this.pongTimeout=(u=(c=h.connectionSettings)===null||c===void 0?void 0:c.pongTimeout)!==null&&u!==void 0?u:1e4}send(e){return v(this,arguments,void 0,(function*(t,n={transport:"ws"}){var o,r,s;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(t)):t;if(n.transport==="http"){try{yield this.request("POST",`/message/${this.class}/${this.id}`,i)}catch(a){if(!a||((o=a?.cause)===null||o===void 0?void 0:o.code)!=="conflictError.keyVersion.mismatch")throw a;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),yield this.request("POST",`/message/${this.class}/${this.id}`,i)}return}const d=yield this.getWebSocket();try{yield this.throttleManager.throttleOperation()}catch(a){throw this.logger.log("error",`WebSocket message throttled: ${a?.message}`),a}const l={event:"message",payload:i};this[N]&&((r=this[N])===null||r===void 0?void 0:r.keyVersion)>-1&&(l.keyVersion=(s=this[N])===null||s===void 0?void 0:s.keyVersion),d.send(JSON.stringify(l))}))}on(e,t,n){this.getWebSocket(!1).then((o=>{this[H].has(e)||this[H].set(e,new Set);const r=this[H].get(e);if(e==="error"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t;this[L].push(i);const d=l=>{try{const a=l?.message||l?.data||l?.type||(typeof l=="string"?l:"WebSocket error occurred");i(new Error(a))}catch{i(new Error("WebSocket error occurred"))}};o.addEventListener("error",d),r.add({handler:i,wsListener:d})}if(e==="connect"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,d=()=>i();o.addEventListener("open",d),r.add({handler:i,wsListener:d})}if(e==="disconnect"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,d=()=>i();o.addEventListener("close",d),r.add({handler:i,wsListener:d})}const s=(i,d,l=!1)=>{const a=l?i.keyVersion:i.payload.keyVersion;if(a===void 0)return d(i.payload);if(a>-1){if(!this.getEncryptionHandler)return this[L].forEach((u=>u(new Error("Encrypted data, but no passphrase or getEncryptionHandler configured!"))));if(!this.encryptionHandler)return this[L].forEach((u=>u(new Error("Encrypted data, but getEncryptionSettings() not called!"))));let c=i.payload.value;l&&(c=i.payload),this.getEncryptionHandlerForKeyVersion(a).then((u=>u?.decrypt(c))).then((u=>{l?i.payload=JSON.parse(u):i.payload.value=JSON.parse(u),d(i.payload)})).catch((u=>{this[L].forEach((h=>h(u)))}))}};if(e==="message"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,d=l=>{const a=JSON.parse(l.data);a.event==="message"&&s(a,i,!0)};o.addEventListener("message",d),r.add({handler:i,wsListener:d})}if(e==="presence:join"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,d=l=>{const a=JSON.parse(l.data);a.event==="presence:join"&&s(a,(c=>{i({connectionId:a?.connectionId,joinedAt:a?.joinedAt,data:c})}),!0)};o.addEventListener("message",d),r.add({handler:i,wsListener:d})}if(e==="presence:leave"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,d=l=>{const a=JSON.parse(l.data);a.event==="presence:leave"&&s(a,(c=>{i({connectionId:a?.connectionId,data:c})}),!0)};o.addEventListener("message",d),r.add({handler:i,wsListener:d})}if(e==="setItem")if(n===void 0){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,d=l=>{const a=JSON.parse(l.data);a.event==="setItem"&&s(a,i)};o.addEventListener("message",d),r.add({handler:i,wsListener:d})}else{if(typeof n!="function")throw new Error("No event handler defined!");const i=n,d=t,l=a=>{const c=JSON.parse(a.data);c.event==="setItem"&&c.payload.prop===d&&s(c,i)};o.addEventListener("message",l),r.add({handler:i,wsListener:l,itemName:d})}if(e==="removeItem")if(n===void 0){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,d=l=>{const a=JSON.parse(l.data);a.event==="removeItem"&&i(a.payload)};o.addEventListener("message",d),r.add({handler:i,wsListener:d})}else{if(typeof n!="function")throw new Error("No event handler defined!");const i=n,d=t,l=a=>{const c=JSON.parse(a.data);c.event==="removeItem"&&c.payload.prop===d&&i(c.payload)};o.addEventListener("message",l),r.add({handler:i,wsListener:l,itemName:d})}}))}off(e,t,n){const o=this[H].get(e);if(o){if(e==="error"){if(typeof t!="function")throw new Error("No event handler defined!");const r=t,s=this[L].indexOf(r);s>-1&&this[L].splice(s,1);for(const i of o)if(i.handler===r){this[V]&&i.wsListener&&this[V].removeEventListener("error",i.wsListener),o.delete(i);break}}else{if(!this[V])return;const r=this[V];let s,i;if(n===void 0){if(typeof t!="function")throw new Error("No event handler defined!");s=t}else{if(typeof n!="function")throw new Error("No event handler defined!");s=n,i=t}for(const d of o){const l=d.handler===s,a=i===void 0||d.itemName===i;if(l&&a){if(d.wsListener){const c=e==="connect"?"open":e==="disconnect"?"close":e==="error"?"error":"message";r.removeEventListener(c,d.wsListener)}o.delete(d);break}}}o.size===0&&this[H].delete(e),this[H].size===0&&this[L].length===0&&this.disconnect()}}connect(){return v(this,void 0,void 0,(function*(){this[V]||(yield this.getWebSocket())}))}disconnect(){return v(this,void 0,void 0,(function*(){this.autoReconnect=!1,this[V]&&(this.hasJoined&&(yield this.leave()),this[V].close(),delete this[V],this[H].clear(),this[L].length=0)}))}getWebSocket(){return v(this,arguments,void 0,(function*(e=!0){if(!this[m].accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken),this[V])return this[V];this.autoReconnect=this.configuredAutoReconnect;const t=_.basePath.replace("http","ws"),n=this[m].apiKey&&this[m].apiSecret?`Basic ${btoa(`${this[m].apiKey}:${this[m].apiSecret}`)}`:void 0,o=this[m].accessToken?`Bearer ${this[m].accessToken}`:void 0,r={auth:this[m].accessToken?o:n};this.idSignature&&(r.idSignature=this.idSignature,this.idSignatureKeyVersion!==void 0&&(r.idSignatureKeyVersion=this.idSignatureKeyVersion));const s=new URLSearchParams(r),i=this[V]=new WebSocket(`${t}/project/${this[m].projectId}/ws/${this.class}/${this.id}?${s}`);this.logger.log("info","initializing WebSocket connection...");let d;i.addEventListener("message",(a=>{let c;try{c=typeof a.data=="string"?JSON.parse(a.data):void 0}catch{c=void 0}if(!c||typeof c!="object")return;const u=c.event;if(u){if(u!=="pong"){if(u!=="connected"&&u!=="resume:ack"||!c.connectionId){if(u==="error"){const h=c.payload;if(typeof h=="string"&&h.toLowerCase().includes("invalid resume")&&(this.logger.log("warn","server signalled invalid resume token â€” clearing saved connectionId"),this.connectionId=void 0,typeof a.stopImmediatePropagation=="function"))try{a.stopImmediatePropagation()}catch{}}}else if(this.connectionId=c.connectionId,typeof a.stopImmediatePropagation=="function")try{a.stopImmediatePropagation()}catch{}}else if(this.logger.log("debug","received pong"),this.clearPongTimer(),typeof a.stopImmediatePropagation=="function")try{a.stopImmediatePropagation()}catch{}}}));const l=new Promise((a=>{d=a}));return i.addEventListener("open",(()=>{if(this.isConnected=!0,this.reconnectAttempts=0,this.connectionId)try{i.send(JSON.stringify({event:"resume",connectionId:this.connectionId}))}catch{}this.startHeartbeat(),typeof d=="function"&&d(i)}),{once:!0}),i.addEventListener("close",(a=>{this.isConnected=!1,this.stopHeartbeat()}),{once:!0}),i.addEventListener("close",(a=>{a?.code===1008&&(this.logger.log("warn","WebSocket closed with 1008 during reconnection"),this.connectionId=void 0),a?.reason&&a?.reason.indexOf("TierLimitExceeded")>-1&&(this.autoReconnect=!1,this.logger.log("error",a.reason),this[L].forEach((h=>h(new Error(a.reason))))),delete this[V];const c=this.hasJoined,u=this.lastJoinData;if(this.hasJoined&&(this.hasJoined=!1),this.autoReconnect){const h=()=>v(this,void 0,void 0,(function*(){const k=Math.min(this.reconnectBaseDelay*Math.pow(2,this.reconnectAttempts),this.reconnectMaxDelay);setTimeout((()=>v(this,void 0,void 0,(function*(){let f;this.reconnectAttempts++,this.logger.log("warn",`${this.reconnectAttempts}. reconnection attempt...`);try{delete this[V],f=yield this.getWebSocket(!1)}catch(w){return this.logger.log("error",w?.message||w?.name||w?.type||w),void h()}const b=()=>v(this,void 0,void 0,(function*(){if(this.reconnectAttempts=0,!this[V])return;const w=this[V];for(const[S,J]of this[H])for(const j of J){let $;S==="connect"?($=()=>j.handler(),w.addEventListener("open",$)):S==="disconnect"?($=()=>j.handler(),w.addEventListener("close",$)):S==="error"?($=T=>{try{const y=T?.message||T?.data||T?.type||(typeof T=="string"?T:"WebSocket error occurred");j.handler(new Error(y))}catch{j.handler(new Error("WebSocket error occurred"))}},w.addEventListener("error",$)):S==="message"?($=T=>{let y;try{y=typeof T.data=="string"?JSON.parse(T.data):void 0}catch{y=void 0}y&&y.event==="message"&&j.handler(y.payload)},w.addEventListener("message",$)):S==="presence:join"?($=T=>{let y;try{y=typeof T.data=="string"?JSON.parse(T.data):void 0}catch{y=void 0}y&&y.event==="presence:join"&&j.handler(y.payload)},w.addEventListener("message",$)):S==="presence:leave"?($=T=>{let y;try{y=typeof T.data=="string"?JSON.parse(T.data):void 0}catch{y=void 0}y&&y.event==="presence:leave"&&j.handler(y.payload)},w.addEventListener("message",$)):S==="setItem"?($=T=>{let y;try{y=typeof T.data=="string"?JSON.parse(T.data):void 0}catch{y=void 0}y&&y.event==="setItem"&&(j.itemName&&y.payload.prop!==j.itemName||j.handler(y.payload))},w.addEventListener("message",$)):S==="removeItem"&&($=T=>{let y;try{y=typeof T.data=="string"?JSON.parse(T.data):void 0}catch{y=void 0}y&&y.event==="removeItem"&&(j.itemName&&y.payload.prop!==j.itemName||j.handler(y.payload))},w.addEventListener("message",$)),$&&(j.wsListener=$)}const I=this[H].get("connect");if(I)for(const S of I)try{S.handler()}catch(J){this.logger.log("error",J)}c&&u&&(yield this.join(u))})),A=()=>{f?.removeEventListener("open",E),f?.removeEventListener("close",x),f?.removeEventListener("error",O)},E=()=>v(this,void 0,void 0,(function*(){yield b(),A()})),x=()=>{A(),h()},O=w=>{this.logger.log("error",w?.message||w?.name||w?.type||w),A(),h()};f.addEventListener("open",E,{once:!0}),f.addEventListener("close",x,{once:!0}),f.addEventListener("error",O,{once:!0}),f.readyState!==WebSocket.CLOSING&&f.readyState!==WebSocket.CLOSED?f.readyState===WebSocket.OPEN&&(yield b(),A()):h()}))),k)}));h()}})),e?l:i}))}clearPongTimer(){this.pongTimer&&(clearTimeout(this.pongTimer),this.pongTimer=void 0)}startPongTimer(){this.clearPongTimer(),this.pongTimer=setTimeout((()=>{var e;this.logger.log("warn","pong timeout â€” closing socket to reconnect");try{(e=this[V])===null||e===void 0||e.close(1006,"pong timeout")}catch{}}),this.pongTimeout)}stopHeartbeat(){this.pingTimer&&(clearInterval(this.pingTimer),this.pingTimer=void 0),this.clearPongTimer()}startHeartbeat(){this.stopHeartbeat();const e=this[V];if(e&&e.readyState===WebSocket.OPEN)try{e.send(JSON.stringify({event:"ping"})),this.startPongTimer()}catch{}this.pingTimer=setInterval((()=>{const t=this[V];if(t&&t.readyState===WebSocket.OPEN)try{t.send(JSON.stringify({event:"ping"})),this.startPongTimer()}catch{}}),this.pingInterval)}join(e){return v(this,void 0,void 0,(function*(){var t,n;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");try{yield this.throttleManager.throttleOperation()}catch(i){throw this.logger.log("error",`Request throttled: ${i?.message}`),i}this.hasJoined=!0,this.lastJoinData=e;const o=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e)):e,r=yield this.getWebSocket(),s={event:"presence:join",payload:o};this[N]&&((t=this[N])===null||t===void 0?void 0:t.keyVersion)>-1&&(s.keyVersion=(n=this[N])===null||n===void 0?void 0:n.keyVersion),r.send(JSON.stringify(s))}))}leave(){return v(this,void 0,void 0,(function*(){var e,t;if(!this.hasJoined)return;try{yield this.throttleManager.throttleOperation()}catch(r){throw this.logger.log("error",`Request throttled: ${r?.message}`),r}this.hasJoined=!1;const n=yield this.getWebSocket(),o={event:"presence:leave"};this[N]&&((e=this[N])===null||e===void 0?void 0:e.keyVersion)>-1&&(o.keyVersion=(t=this[N])===null||t===void 0?void 0:t.keyVersion),n.send(JSON.stringify(o))}))}getJoinedConnections(){return v(this,void 0,void 0,(function*(){var e;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let t;try{t=yield this.request("GET",`/presence-list/${this.class}/${this.id}`)}catch(o){if(!o||((e=o?.cause)===null||e===void 0?void 0:e.code)!=="conflictError.keyVersion.mismatch")throw o;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),t=yield this.request("GET",`/presence-list/${this.class}/${this.id}`)}const n=t;return Promise.all(n?.map((o=>v(this,void 0,void 0,(function*(){const r=yield this.getEncryptionHandlerForKeyVersion(o.keyVersion),s=r?JSON.parse(yield r.decrypt(o.data)):o.data;return{connectionId:o.connectionId,joinedAt:o.joinedAt,data:s}}))))||[])}))}}Z=H;class ye extends _{constructor(e,t){typeof t=="string"?super(e,t):(super(e,t),t?.ttl&&(this.ttl=t?.ttl))}setItem(e,t,n){return v(this,void 0,void 0,(function*(){var o,r;if(!e)throw new Error("No name passed!");if(!t&&t!==0&&t!==""&&t!==!1)throw new Error("No value passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const s=n?.ttl||this.ttl,i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(t)):t;let d;try{d=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}`,{value:i,ttl:s,ifAbsent:n?.ifAbsent,updatedAt:n?.updatedAt})}catch(a){if(!a||((o=a?.cause)===null||o===void 0?void 0:o.code)!=="conflictError.keyVersion.mismatch")throw a;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),d=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}`,{value:i,ttl:s,ifAbsent:n?.ifAbsent})}const l=d;return l&&{value:l?.value,expiresAt:l?.expiresAt,keyVersion:(r=l?.keyVersion)!==null&&r!==void 0?r:void 0,createdAt:l?.createdAt,updatedAt:l?.updatedAt}}))}setItems(e){return v(this,void 0,void 0,(function*(){var t,n;if(!e||Object.keys(e).length===0)throw new Error("No items passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");for(const s of Object.keys(e)){const i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e[s].value)):e[s].value;e[s].value=i,(n=e[s]).ttl||(n.ttl=this.ttl)}let o;try{o=yield this.request("POST",`/cache/${this.class}/${this.id}`,e)}catch(s){if(!s||((t=s?.cause)===null||t===void 0?void 0:t.code)!=="conflictError.keyVersion.mismatch")throw s;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("POST",`/cache/${this.class}/${this.id}`,e)}const r=o;return Object.keys(r).reduce(((s,i)=>{var d,l,a,c,u,h,k,f,b,A;return s[i]={value:(l=(d=r[i])===null||d===void 0?void 0:d.value)!==null&&l!==void 0?l:null,expiresAt:(c=(a=r[i])===null||a===void 0?void 0:a.expiresAt)!==null&&c!==void 0?c:0,keyVersion:(h=(u=r[i])===null||u===void 0?void 0:u.keyVersion)!==null&&h!==void 0?h:void 0,createdAt:(f=(k=r[i])===null||k===void 0?void 0:k.createdAt)!==null&&f!==void 0?f:0,updatedAt:(A=(b=r[i])===null||b===void 0?void 0:b.updatedAt)!==null&&A!==void 0?A:0},s}),{})}))}getItem(e){return v(this,void 0,void 0,(function*(){var t,n;if(!e)throw new Error("No name passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let o;try{o=yield this.request("GET",`/cache/${this.class}/${this.id}/${e}`)}catch(l){if(!l||((t=l?.cause)===null||t===void 0?void 0:t.code)!=="conflictError.keyVersion.mismatch")throw l;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("GET",`/cache/${this.class}/${this.id}/${e}`)}const r=o,s=r?.value;if(!s)return;const i=yield this.getEncryptionHandlerForKeyVersion(r.keyVersion),d=i?JSON.parse(yield i.decrypt(s)):s;return r?.keyVersion>-1&&r.keyVersion!==((n=this[N])===null||n===void 0?void 0:n.keyVersion)&&(this.autoUpdateOldEncryptedValues?(this.logger.log("info",`Item "${e}" has an old encryption and will be automatically updated now by setting it again.`),yield this.setItem(e,d,{ttl:r.expiresAt-Date.now()})):this.logger.log("warn",`Item "${e}" has an old encryption and can be updated by setting it again.`)),{value:d,expiresAt:r.expiresAt,keyVersion:r.keyVersion,createdAt:r.createdAt,updatedAt:r.updatedAt}}))}getItems(e){return v(this,void 0,void 0,(function*(){var t,n;if(!e||e.length===0)throw new Error("No names passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let o;try{o=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,e)}catch(l){if(!l||((t=l?.cause)===null||t===void 0?void 0:t.code)!=="conflictError.keyVersion.mismatch")throw l;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,e)}const r=o;if(Object.keys(r).length===0)return;const s={},i={};for(const l of Object.keys(r)){const a=r[l],c=a?.value;if(!c)continue;const u=yield this.getEncryptionHandlerForKeyVersion(a.keyVersion),h=u?JSON.parse(yield u.decrypt(c)):c;a?.keyVersion>-1&&a.keyVersion!==((n=this[N])===null||n===void 0?void 0:n.keyVersion)&&(s[l]=a),i[l]={value:h,expiresAt:a.expiresAt,keyVersion:a.keyVersion,createdAt:a.createdAt,updatedAt:a.updatedAt}}const d=Object.keys(s);if(d.length>0)if(this.autoUpdateOldEncryptedValues){this.logger.log("info",`These items "${d.join(",")}" have an old encryption and will be automatically updated now by setting them again.`);const l=d.reduce(((a,c)=>(a[c]={value:i[c].value,ttl:s[c].expiresAt-Date.now()},a)),{});yield this.setItems(l)}else this.logger.log("warn",`These items "${d.join(",")}" have an old encryption and can be updated by setting them again.`);return i}))}getAllItems(e){return v(this,void 0,void 0,(function*(){var t,n;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let o;try{o=yield this.request("GET",`/cache/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}catch(i){if(!i||((t=i?.cause)===null||t===void 0?void 0:t.code)!=="conflictError.keyVersion.mismatch")throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("GET",`/cache/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}const r=o;if(Object.keys(r).length===0)return;const s={};for(const i of Object.keys(r)){const d=r[i],l=d?.value;if(!l)continue;const a=yield this.getEncryptionHandlerForKeyVersion(d.keyVersion),c=a?JSON.parse(yield a.decrypt(l)):l;s[i]={value:c,expiresAt:d.expiresAt,keyVersion:(n=d.keyVersion)!==null&&n!==void 0?n:void 0,createdAt:d.createdAt,updatedAt:d.updatedAt}}return s}))}getAllKeys(e){return v(this,void 0,void 0,(function*(){return yield this.request("GET",`/cache-keys/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}))}removeItem(e){return v(this,void 0,void 0,(function*(){if(!e)throw new Error("No name passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}/${e}`)}))}removeItems(e){return v(this,void 0,void 0,(function*(){if(!e||e.length===0)throw new Error("No names passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}`,e)}))}incrementItem(e){return v(this,arguments,void 0,(function*(t,n=1,o){var r;if(!t)throw new Error("No name passed!");if(n==null)throw new Error("No value passed!");if(typeof n!="number")throw new Error("Value needs to be a number!");const s=o?.ttl||this.ttl,i=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}/increment`,{value:n,ttl:s,updatedAt:o?.updatedAt});return{value:i?.value,expiresAt:i?.expiresAt,keyVersion:(r=i?.keyVersion)!==null&&r!==void 0?r:void 0,createdAt:i?.createdAt,updatedAt:i?.updatedAt}}))}decrementItem(e){return v(this,arguments,void 0,(function*(t,n=1,o){var r;if(!t)throw new Error("No name passed!");if(n==null)throw new Error("No value passed!");if(typeof n!="number")throw new Error("Value needs to be a number!");const s=o?.ttl||this.ttl,i=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}/decrement`,{value:n,ttl:s,updatedAt:o?.updatedAt});return{value:i?.value,expiresAt:i?.expiresAt,keyVersion:(r=i?.keyVersion)!==null&&r!==void 0?r:void 0,createdAt:i?.createdAt,updatedAt:i?.updatedAt}}))}push(e,t,n){return v(this,void 0,void 0,(function*(){var o;if(!e)throw new Error("No name passed!");const r=n?.ttl||this.ttl,s=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/push`,{value:t,ttl:r,updatedAt:n?.updatedAt});return{value:s?.value,expiresAt:s?.expiresAt,keyVersion:(o=s?.keyVersion)!==null&&o!==void 0?o:void 0,createdAt:s?.createdAt,updatedAt:s?.updatedAt}}))}splice(e,t,n,o,r){return v(this,void 0,void 0,(function*(){var s;if(!e)throw new Error("No name passed!");const i=r?.ttl||this.ttl,d=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/splice`,{startIndex:t,deleteCount:n,items:o,ttl:i,updatedAt:r?.updatedAt});return{value:d?.value,expiresAt:d?.expiresAt,keyVersion:(s=d?.keyVersion)!==null&&s!==void 0?s:void 0,createdAt:d?.createdAt,updatedAt:d?.updatedAt}}))}merge(e,t,n){return v(this,void 0,void 0,(function*(){var o;if(!e)throw new Error("No name passed!");const r=n?.ttl||this.ttl,s=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/merge`,{value:t,ttl:r,updatedAt:n?.updatedAt});return{value:s?.value,expiresAt:s?.expiresAt,keyVersion:(o=s?.keyVersion)!==null&&o!==void 0?o:void 0,createdAt:s?.createdAt,updatedAt:s?.updatedAt}}))}setIn(e,t,n,o){return v(this,void 0,void 0,(function*(){var r;if(!e)throw new Error("No name passed!");if(!t||t.length===0)throw new Error("Path must not be empty.");const s=o?.ttl||this.ttl,i=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/set-in`,{path:t,value:n,ttl:s,updatedAt:o?.updatedAt});return{value:i?.value,expiresAt:i?.expiresAt,keyVersion:(r=i?.keyVersion)!==null&&r!==void 0?r:void 0,createdAt:i?.createdAt,updatedAt:i?.updatedAt}}))}clear(){return v(this,void 0,void 0,(function*(){yield this.request("DELETE",`/cache/${this.class}/${this.id}`)}))}}const G={};function fe(p,e){return`${`${e.projectId}-${e.apiKey}`}-${`${p.class||"_undefined_"}-${p.id}`}`}const U=(p,e)=>{const t=e||re(),n=fe(p,t);if(G[n])return G[n];const o=new ye(t,p);return G[n]=o,o};function me(p,e,t){const[n,o]=C.useState(),[r,s]=C.useState(),[i,d]=C.useState(!0),l=U({...t?.instanceOptions,id:p},t?.credentials),a=t?.bind??!0;if(C.useEffect(()=>{if(!l)return;d(!0);try{(async function(u,h,k){let f;typeof h=="string"?(f=await u.getItem(h),k&&k({[`${h}`]:f})):(f=await u.getItems(h),k&&k(f))})(l,e,u=>{o(u),d(!1)})}catch(u){s(u),d(!1)}const c={};return a&&(Array.isArray(e)?e:[e]).forEach(u=>{const h=(k=>function(f){o(b=>({...b,[`${k}`]:f}))})(u);c[u]=h,l.on("setItem",u,h)}),()=>{a&&Object.keys(c).forEach(u=>{l.off("setItem",u,c[u])})}},[e]),typeof e=="string"){const c=async()=>{d(!0);try{const h=await l.getItem(e);return d(!1),h}catch(h){s(h),d(!1)}},u=h=>{h&&o(k=>({...k,[`${e}`]:h}))};return[l,n?n[e]:void 0,u,c,r,s,i]}return[l,n,o,async()=>{d(!0);try{const c=await l.getItems(e);return d(!1),c}catch(c){s(c),d(!1)}},r,s,i]}const we=(p,e,t)=>{const[n,o,r,,s,i,d]=me(p,e,t);return[o,async l=>{try{const a=await n.setItems(l);r({...o,...a})}catch(a){i(a)}},s,d]};function ee({style:p,children:e}){return g.jsx("div",{className:"vaultrice-card",style:p,children:e})}ee.__docgenInfo={description:`A styled card container for Vaultrice UI.

@param props - CardProps
@returns A React div element styled as a card.`,methods:[],displayName:"Card",props:{style:{required:!1,tsType:{name:"ReactCSSProperties",raw:"React.CSSProperties"},description:""},children:{required:!1,tsType:{name:"ReactReactNode",raw:"React.ReactNode"},description:""}}};function te({percentage:p=0,style:e}){const[t,n]=C.useState(0);return C.useEffect(()=>{setTimeout(()=>{n(p)},1300)},[p]),g.jsx("div",{className:"vaultrice-meter-container",style:e,children:g.jsxs("div",{className:`vaultrice-meter-control ${t>100?"vaultrice-meter-control-error":t>90?"vaultrice-meter-control-warning":""}`,children:[g.jsx("div",{className:"vaultrice-meter-track",style:{width:t<100?"100%":`${100/(t/100)}%`}}),g.jsx("div",{className:"vaultrice-meter-state",style:{width:`${t}%`,borderRadius:t>=100?"14px":"14px 0 0 14px",opacity:t===0?0:1}})]})})}te.__docgenInfo={description:`A visual meter bar for displaying percentage values.
Animates to the given percentage after mount/update.

@param props - MeterProps
@returns A React element representing the meter bar.`,methods:[],displayName:"Meter",props:{percentage:{required:!1,tsType:{name:"number"},description:"",defaultValue:{value:"0",computed:!1}},style:{required:!1,tsType:{name:"ReactCSSProperties",raw:"React.CSSProperties"},description:""}}};function ie({onClick:p,disabled:e,style:t,children:n}){return g.jsx("button",{className:"vaultrice-button",style:t,type:"button",disabled:e,onClick:p,children:n})}ie.__docgenInfo={description:`A styled button component for Vaultrice UI.

@param props - ButtonProps
@returns A React button element.`,methods:[],displayName:"Button",props:{style:{required:!1,tsType:{name:"ReactCSSProperties",raw:"React.CSSProperties"},description:""},children:{required:!1,tsType:{name:"ReactReactNode",raw:"React.ReactNode"},description:""},disabled:{required:!1,tsType:{name:"boolean"},description:""},onClick:{required:!1,tsType:{name:"ReactMouseEventHandler",raw:"React.MouseEventHandler<HTMLButtonElement>",elements:[{name:"HTMLButtonElement"}]},description:""}}};function Ee(p,e,t,n,o,r){const[s,i]=C.useState(),[d,l]=C.useState(!1),[a,c]=C.useState(!1),[u,h]=C.useState(!1);t||=e;const k=n?n.class||"_undefined_":o?.class||"_undefined_",f=n?n.ttl||3600*1e3:o?.ttl||3600*1e3,b=`${p}-user-${e}-voted`,A=`vaultrice-${p}-user-${t}-${k}-voted`,E=`${p}-user-${e}`,x=p,O=e?U({...n,id:E},r):void 0;return C.useEffect(()=>{const I=async()=>{if(l(!1),e){const S=await O?.getItem(b);c(!!S)}else{let S=window.localStorage.getItem(A);S&&parseInt(S)+f*2<Date.now()&&(window.localStorage.removeItem(A),S=null),c(!!S)}l(!0)};try{I()}catch(S){i(S)}},[b,O,e,t,A]),[d,u,a,async I=>{try{if(a)return;h(!0),await U({...o,id:x},r).incrementItem(`${x}-choices-${I}`),e?await O?.setItem(b,Date.now()):window.localStorage.setItem(A,Date.now().toString()),h(!1),c(!0)}catch(S){i(S)}},s]}const Se=({id:p,choices:e=[],choicesInstanceOptions:t,credentials:n,bind:o=!0,showPercentage:r=!1,showTotalVotes:s=!0})=>{const[i]=C.useState(e.map(c=>`${p}-choices-${c.id}`)),[d,,,l]=we(p,i,{credentials:n,instanceOptions:t,bind:o});if(!l&&!d)return g.jsxs("div",{className:"vaultrice-voting-result vaultrice-voting-expired",children:[g.jsxs("div",{className:"vaultrice-voting--result-label",children:[g.jsx("span",{className:"vaultrice-voting-expired-icon","aria-label":"Voting closed",role:"img",children:"ðŸ”’"}),g.jsx("label",{className:"vaultrice-voting-expired-label",children:"Voting closed"}),g.jsx("span",{className:"vaultrice-voting-result-label-tag",children:"Expired"})]}),g.jsx("p",{className:"vaultrice-voting-expired-text",children:"This voting has expired and is no longer accepting responses."})]});if(l)return"loading...";if(!d)return null;const a=Object.values(d).reduce((c,u)=>u?.value?c+u.value:c,0);return g.jsxs("div",{className:"vaultrice-voting-results",children:[e.map(c=>{const u=d[`${p}-choices-${c.id}`],h=u?.value?u.value/a*100:0;return g.jsxs("div",{className:"vaultrice-voting-result",children:[g.jsxs("div",{className:"vaultrice-voting--result-label",children:[g.jsx("label",{children:c.label}),g.jsx("span",{className:"vaultrice-voting-result-label-tag",children:r?`${h.toFixed(1)}%`:u?.value||0})]}),g.jsx(te,{percentage:h})]},c.id)}),s&&g.jsxs("div",{style:{marginTop:12,textAlign:"right",color:"#666",fontSize:13},children:["Total votes: ",g.jsx("b",{children:a})]})]})},ne=({id:p,title:e,description:t,voteLabel:n="vote",choices:o=[],choicesInstanceOptions:r,userId:s,userIdForLocalStorage:i,userInstanceOptions:d,credentials:l,bind:a=!0,showPercentage:c=!1,showTotalVotes:u=!0})=>{const[h,k]=C.useState(o?.[0]?.id),[f,b,A,E]=Ee(p,s,i,d,r,l);return f?g.jsxs(ee,{children:[!!e&&g.jsx("h3",{className:"vaultrice-voting-title",children:e}),!!t&&g.jsx("p",{className:"vaultrice-voting-description",children:t}),!!A&&g.jsx(Se,{id:p,choices:o,choicesInstanceOptions:r,credentials:l,bind:a,showPercentage:c,showTotalVotes:u}),!A&&g.jsxs(g.Fragment,{children:[g.jsx("div",{className:"vaultrice-voting-choices",children:o.map(x=>g.jsxs("div",{className:"vaultrice-voting-choice",onClick:O=>{O.target.tagName!=="INPUT"&&k(x.id)},style:{cursor:"pointer"},children:[g.jsx("input",{type:"radio",name:x.id,value:x.id,checked:x.id===h,onChange:()=>{k(x.id)},style:{cursor:"pointer"}}),g.jsx("label",{htmlFor:x.id,style:{cursor:"pointer"},children:x.label})]},x.id))}),g.jsx(ie,{onClick:()=>{E(h)},disabled:b,children:b?"...voting":n})]}),g.jsxs("div",{className:"vaultrice-voting-disclaimer",children:["Powered by ",g.jsx("a",{href:"https://www.vaultrice.com",target:"_blank",rel:"noreferrer",children:"vaultrice.com"})," - get yours ",g.jsx("a",{href:"https://www.vaultrice.app/register",target:"_bland",children:"for free!"})]})]}):null};ne.__docgenInfo={description:`Voting component for Vaultrice UI.

Renders a voting form with selectable choices, handles voting logic,
and displays results after voting.

@param props - VotingProps
@returns A React element for voting.`,methods:[],displayName:"Voting",props:{id:{required:!0,tsType:{name:"string"},description:"Unique identifier for the voting instance."},title:{required:!1,tsType:{name:"union",raw:"string | ReactNode",elements:[{name:"string"},{name:"ReactNode"}]},description:"Optional headline for the voting."},description:{required:!1,tsType:{name:"union",raw:"string | ReactNode",elements:[{name:"string"},{name:"ReactNode"}]},description:"Optional description for the voting."},voteLabel:{required:!1,tsType:{name:"string"},description:`Optional label for the voting button.
@default 'vote'`,defaultValue:{value:"'vote'",computed:!1}},choices:{required:!1,tsType:{name:"Array",elements:[{name:"signature",type:"object",raw:`{
  /**
   * Unique identifier for the choice.
   */
  id: string,
  /**
   * Display label for the choice.
   */
  label: string | ReactNode
}`,signature:{properties:[{key:"id",value:{name:"string",required:!0},description:"Unique identifier for the choice."},{key:"label",value:{name:"union",raw:"string | ReactNode",elements:[{name:"string"},{name:"ReactNode"}],required:!0},description:"Display label for the choice."}]}}],raw:"Array<ChoiceOption>"},description:"Array of available choices for the voting.",defaultValue:{value:"[]",computed:!1}},choicesInstanceOptions:{required:!1,tsType:{name:"InstanceOptions"},description:"Optional instance options for managing choices storage."},userId:{required:!1,tsType:{name:"string"},description:"Optional user identifier. If provided, voting status is stored in Vaultrice; otherwise, localStorage is used."},userInstanceOptions:{required:!1,tsType:{name:"InstanceOptions"},description:"Optional instance options for managing user storage."},credentials:{required:!1,tsType:{name:"Credentials"},description:"Optional credentials for accessing Vaultrice SDK, if not using vaultrice.init."},bind:{required:!1,tsType:{name:"boolean"},description:`Whether to bind to changes.
@default true`,defaultValue:{value:"true",computed:!1}},userIdForLocalStorage:{required:!1,tsType:{name:"string"},description:`Optional user identifier for localStorage.
If not provided it wull use the passed userId or undefined.
@default 'undefined'`},showPercentage:{required:!1,tsType:{name:"boolean"},description:"Show percentage instead of raw vote count.",defaultValue:{value:"false",computed:!1}},showTotalVotes:{required:!1,tsType:{name:"boolean"},description:`Show total votes below the results.
@default true`,defaultValue:{value:"true",computed:!1}}}};const $e={title:"Vaultrice/Voting",component:ne,parameters:{layout:"centered"},tags:["autodocs"],argTypes:{credentials:{control:!1}},args:{}},D={args:{id:"voting1",title:"Vote for our latest feature proposal",description:"Every voice counts to get this component like you want it.",choices:[{id:"op1",label:"Create a render prop."},{id:"op2",label:"Have a dark theme."},{id:"op3",label:g.jsxs(g.Fragment,{children:["I'm already ",g.jsx("a",{href:"https://www.vaultrice.com/",target:"_blank",rel:"noreferrer",children:"happy"})," with what ",g.jsx("strong",{children:"I got"}),"."]})}],credentials:{projectId:"253c8eeb-dcdf-4d67-8557-a7a8b92228be",apiKey:"08ee33b7-9e85-47b8-a164-87f0afba70fc",apiSecret:"27b20eee-3171-4727-8280-17ef62556c9f"}}};D.parameters={...D.parameters,docs:{...D.parameters?.docs,source:{originalSource:`{
  args: {
    id: 'voting1',
    title: 'Vote for our latest feature proposal',
    description: 'Every voice counts to get this component like you want it.',
    choices: [{
      id: 'op1',
      label: 'Create a render prop.'
    }, {
      id: 'op2',
      label: 'Have a dark theme.'
    }, {
      id: 'op3',
      label: <>I'm already <a href='https://www.vaultrice.com/' target='_blank' rel='noreferrer'>happy</a> with what <strong>I got</strong>.</>
    }],
    credentials: {
      projectId: import.meta.env.VITE_VAULTRICE_PROJECTID,
      apiKey: import.meta.env.VITE_VAULTRICE_APIKEY,
      apiSecret: import.meta.env.VITE_VAULTRICE_APISECRET
    }
  }
}`,...D.parameters?.docs?.source}}};const Ve=["Primary"];export{D as Primary,Ve as __namedExportsOrder,$e as default};
