let z;const X=()=>z;function p(g,e,t,n){return new(t||(t=Promise))((function(o,r){function a(d){try{l(n.next(d))}catch(s){r(s)}}function i(d){try{l(n.throw(d))}catch(s){r(s)}}function l(d){var s;d.done?o(d.value):(s=d.value,s instanceof t?s:new t((function(c){c(s)}))).then(a,i)}l((n=n.apply(g,e||[])).next())}))}const U="NON_LOCAL_STORAGE_LOCAL_ID",_=(g,e)=>typeof window<"u"&&window.localStorage?window.localStorage.getItem(`${U}:${g}:${e}`):null,Q=(g,e,t)=>{typeof window<"u"&&window.localStorage&&window.localStorage.setItem(`${U}:${g}:${e}`,t)};function Z(g,e,t){return p(this,arguments,void 0,(function*(n,o,r,a={iterations:1e5,hash:"SHA-512",derivedKeyType:{name:"AES-GCM",length:256}}){const i=new TextEncoder,l=yield crypto.subtle.importKey("raw",i.encode(n+":"+o),"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:a?.iterations||1e5,hash:a?.hash||"SHA-512"},l,a?.derivedKeyType||{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}))}function ee(g,e){return p(this,arguments,void 0,(function*(t,n,o={algorithm:"AES-GCM"}){const r=new TextEncoder,a=crypto.getRandomValues(new Uint8Array(12)),i=yield crypto.subtle.encrypt({name:o?.algorithm||"AES-GCM",iv:a},t,r.encode(n));return JSON.stringify({iv:btoa(String.fromCharCode(...a)),data:btoa(String.fromCharCode(...new Uint8Array(i)))})}))}function te(g,e){return p(this,arguments,void 0,(function*(t,n,o={algorithm:"AES-GCM"}){const r=JSON.parse(n),a=new TextDecoder,i=Uint8Array.from(atob(r.iv),(s=>s.charCodeAt(0))),l=Uint8Array.from(atob(r.data),(s=>s.charCodeAt(0))),d=yield crypto.subtle.decrypt({name:o?.algorithm||"AES-GCM",iv:i},t,l);return a.decode(d)}))}let F;F=typeof crypto<"u"&&typeof crypto.randomUUID=="function"?()=>crypto.randomUUID():()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(g=>{const e=16*Math.random()|0;return(g==="x"?e:3&e|8).toString(16)}));var G=F;const D=["error","warn","info","debug"];let ie=class{constructor(e){this.level=e}log(e,t){D.indexOf(this.level)<D.indexOf(e)||console[e](t)}};var R=(g="warn")=>new ie(g);function K(g){let e=g.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4!=0;)e+="=";return atob(e)}function ne(g){if(typeof g!="string")throw new Error("JWT must be a string");const e=g.split(".");if(e.length!==3)throw new Error("JWT should consist of three parts: header.payload.signature");const[t,n,o]=e,r=K(t);let a;try{a=JSON.parse(r)}catch(d){throw new Error("Invalid JWT header JSON: "+d.message)}const i=K(n);let l;try{l=JSON.parse(i)}catch(d){throw new Error("Invalid JWT payload JSON: "+d.message)}return{header:a,payload:l,signatureHex:(function(d){let s="";for(let c=0;c<d.length;c++)s+=d.charCodeAt(c).toString(16).padStart(2,"0");return s})(K(o))}}const y=Symbol("vaultrice/credentials"),T=Symbol("vaultrice/encryptionSettings"),C=Symbol("vaultrice/previousEncryptionSettings"),I=Symbol("vaultrice/errorHandlers"),k=Symbol("vaultrice/ws"),V=Symbol("vaultrice/eventHandlers"),j=Symbol("vaultrice/accessTokenExpiringHandlers"),oe={enabled:!0,maxOperations:100,windowMs:6e4,operationDelay:0};let re=class{constructor(e){this.operationHistory=[],this.lastOperationTime=0,this.operationConfig=Object.assign(Object.assign({},oe),e||{})}updateConfig(e){this.operationConfig=Object.assign(Object.assign({},this.operationConfig),e)}cleanupHistory(e,t){const n=Date.now()-t,o=e.findIndex((r=>r.timestamp>n));o>0?e.splice(0,o):o===-1&&(e.length=0)}isAllowed(e,t,n){return this.cleanupHistory(e,n),e.length<t}calculateDelay(e,t){if(t===0)return 0;const n=Date.now()-e;return Math.max(0,t-n)}throttleOperation(){return p(this,void 0,void 0,(function*(){if(!this.operationConfig.enabled)return;if(!this.isAllowed(this.operationHistory,this.operationConfig.maxOperations,this.operationConfig.windowMs))throw new Error(`Operation rate limit exceeded. Maximum ${this.operationConfig.maxOperations} operations per ${this.operationConfig.windowMs}ms allowed.`);const e=this.calculateDelay(this.lastOperationTime,this.operationConfig.operationDelay);var t;e>0&&(yield(t=e,new Promise((o=>setTimeout(o,t)))));const n=Date.now();this.operationHistory.push({timestamp:n}),this.lastOperationTime=n}))}getOperationStatus(){return this.cleanupHistory(this.operationHistory,this.operationConfig.windowMs),{enabled:this.operationConfig.enabled,currentCount:this.operationHistory.length,maxOperations:this.operationConfig.maxOperations,windowMs:this.operationConfig.windowMs,remaining:Math.max(0,this.operationConfig.maxOperations-this.operationHistory.length)}}reset(){this.operationHistory.length=0,this.lastOperationTime=0}};var B;function se(g,e){return _(g,e)||`${G()}-${G()}`}const P="_undefined_";class L{constructor(e,t={class:P,autoUpdateOldEncryptedValues:!0,logLevel:"warn"}){this.class=P,this[B]=[];let n={class:P,logLevel:"warn"};if(typeof t=="string"?(this.id=t,n={class:P,logLevel:"warn"}):(this.id=t.id||se(e.projectId,t.class||P),n=t),this.logger=R(n.logLevel),!e||typeof e!="object"||typeof e.projectId!="string")throw new Error("Invalid credentials!");const o=typeof e.apiKey=="string"&&typeof e.apiSecret=="string",r=typeof e.accessToken=="string",a=typeof e.getAccessToken=="function",i=[o,a].filter(Boolean).length,l=r&&!a;if(i===0&&!l)throw new Error("Invalid credentials! Must provide one of: (apiKey + apiSecret), accessToken, or getAccessToken function");if(i>1||l&&i>0)throw new Error("Invalid credentials! Provide only one primary authentication method. You can combine getAccessToken with an initial accessToken for performance.");if((e.apiKey||e.apiSecret)&&!o)throw new Error("Invalid credentials! Both apiKey and apiSecret are required when using direct authentication");if(this.throttleManager=new re(n.throttling),typeof t=="string"||t?.id||Q(e.projectId,t.class||P,this.id),this[y]=Object.assign({},e),typeof this[y].apiKey=="string"||typeof this[y].apiSecret=="string"||typeof this[y].accessToken!="string"&&!e.getAccessToken||(delete this[y].apiKey,delete this[y].apiSecret),e.getAccessToken&&(this.getAccessTokenFn=e.getAccessToken,delete this[y].getAccessToken),this.class=n.class||P,n.passphrase&&n.getEncryptionHandler)throw new Error("Either define a passphrase or a getEncryptionHandler, but not both!");if(n.getEncryptionHandler&&(this.getEncryptionHandler=n.getEncryptionHandler),n.passphrase&&(this.getEncryptionHandler=d=>p(this,void 0,void 0,(function*(){var s,c,h,u;const S=yield Z(n.passphrase,this.id,d.salt,n.keyDerivationOptions),f=!((c=(s=n.keyDerivationOptions)===null||s===void 0?void 0:s.derivedKeyType)===null||c===void 0)&&c.name?{algorithm:(u=(h=n.keyDerivationOptions)===null||h===void 0?void 0:h.derivedKeyType)===null||u===void 0?void 0:u.name}:void 0;return{encrypt:x=>ee(S,x,f),decrypt:x=>te(S,x,f)}}))),n.autoUpdateOldEncryptedValues===void 0&&(n.autoUpdateOldEncryptedValues=!0),this.autoUpdateOldEncryptedValues=n.autoUpdateOldEncryptedValues,n.idSignature&&(this.idSignature=n.idSignature),this.idSignature&&(this.idSignatureKeyVersion=n.idSignatureKeyVersion),a)if(r){this.logger.log("debug","Using token provider with initial access token");try{this.useAccessTokenAndRememberToAcquireTheNext(this[y].accessToken)}catch{this.logger.log("warn","Initial access token is invalid, acquiring new token"),this[y].accessToken=void 0,this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}))}}else this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}));else r||(this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0})))}static executeWithRetry(e,t,n){return p(this,arguments,void 0,(function*(o,r,a,i={}){var l,d,s,c;const{maxRetries:h=3,initialDelay:u=100,maxDelay:S=2e3,backoffMultiplier:f=2}=i;let x,A=0;for(;A<=h;)try{return yield o()}catch(w){x=w;let H=!1,N="";const m=["Please try again in a moment","Please retry","Service temporarily unavailable","temporarily unavailable","try again later"];if(w&&typeof w=="object"){N=w.message||w.toString();const $=(l=w?.cause)===null||l===void 0?void 0:l.code;$&&$.indexOf("retry")>-1?H=!0:N&&(H=m.some((J=>N.toLowerCase().includes(J.toLowerCase()))))}else typeof w=="string"?(N=w,H=m.some(($=>N.toLowerCase().includes($.toLowerCase())))):(H=w?.name==="TypeError"||((d=w?.message)===null||d===void 0?void 0:d.includes("fetch"))||((s=w?.message)===null||s===void 0?void 0:s.includes("network"))||((c=w?.message)===null||c===void 0?void 0:c.includes("timeout")),N=w?.message||"Unknown error");if(H&&A<h){a&&a.log("warn",`${r} failed (attempt ${A+1}/${h+1}): ${N}. Retrying...`),A++;const $=Math.min(u*Math.pow(f,A-1),S),J=$+Math.random()*(.1*$);a&&a.log("debug",`Waiting ${Math.round(J)}ms before retry attempt ${A+1}`),yield new Promise((O=>setTimeout(O,J)));continue}throw w}throw x}))}static retrieveAccessToken(e,t,n,o){return p(this,void 0,void 0,(function*(){if(typeof e!="string"||!e)throw new Error("projectId not valid!");if(typeof t!="string"||!t)throw new Error("apiKey not valid!");if(typeof n!="string"||!n)throw new Error("apiSecret not valid!");const r={Authorization:`Basic ${btoa(`${t}:${n}`)}`};return typeof o?.origin=="string"&&o?.origin.length>0&&(r.Origin=o.origin),L.executeWithRetry((()=>p(this,void 0,void 0,(function*(){var a;const i=yield fetch(`${L.basePath}/project/${e}/auth/token`,{method:"GET",headers:r}),l=i.headers.get("content-type");let d;if(l)try{l.indexOf("text/plain")===0?d=yield i.text():l.indexOf("application/json")===0&&(d=yield i.json())}catch{d=`${i.status} - ${i.statusText}`}if(!i.ok){if(i.status===403&&d&&((a=d?.cause)===null||a===void 0?void 0:a.code)==="authorizationError.origin.server.notFound"&&(d.message='Failed to retrieve access token: access denied. This is due to an API key origin restriction. If minting a token from a backend for use in a browser, pass the browser-origin when calling retrieveAccessToken() e.g. NonLocalStorage.retrieveAccessToken("projectId", "apiKey", "apiSecret", { origin: req.headers.origin }).'),typeof d=="string")throw new Error(d);if(d)throw d;if(i.status!==404)throw new Error(`${i.status} - ${i.statusText}`)}return d}))),"Token retrieval",R("warn"))}))}useAccessTokenAndRememberToAcquireTheNext(e){if(!e)throw new Error("No accessToken!");const t=this.useAccessToken(e),n=Math.max(t-12e4,1e3);this.logger.log("debug",`Scheduling next token refresh in ${n}ms`),setTimeout((()=>{this.isGettingAccessToken=this.acquireAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0})).catch((()=>{this.isGettingAccessToken=void 0}))}),n)}acquireAccessToken(){return p(this,void 0,void 0,(function*(){try{let e;if(this.getAccessTokenFn){if(this.logger.log("debug","Acquiring access token via custom provider"),e=yield this.getAccessTokenFn(),typeof e!="string"||!e)throw new Error("getAccessToken function must return a non-empty string")}else{if(!this[y].apiKey||!this[y].apiSecret)throw new Error("No authentication method available for token acquisition");this.logger.log("debug","Acquiring access token via API key/secret"),e=yield L.retrieveAccessToken(this[y].projectId,this[y].apiKey,this[y].apiSecret)}this.useAccessTokenAndRememberToAcquireTheNext(e)}catch(e){throw this.logger.log("error",`Access token acquisition failed: ${e?.message||e?.name||e?.type||e}`),e}}))}useAccessToken(e){if(typeof e!="string"||!e)throw new Error("accessToken not valid!");const t=ne(e);this[y].accessToken=e;const n=t.payload.exp-Date.now();if(n-12e4<0)throw new Error("accessToken not valid anymore");return setTimeout((()=>{this[j].forEach((o=>o()))}),Math.max(n-12e4,0)),n}onAccessTokenExpiring(e){this[j].push(e)}offAccessTokenExpiring(e){const t=this[j].indexOf(e);t!==-1&&this[j].splice(t,1)}getEncryptionHandlerForKeyVersion(e){return p(this,void 0,void 0,(function*(){var t,n,o,r;if(e>-1&&(e!==((t=this[T])===null||t===void 0?void 0:t.keyVersion)&&(this[C]&&this[C].length!==0||(yield this.getEncryptionSettings())),e!==((n=this[T])===null||n===void 0?void 0:n.keyVersion))){if(!this[C]||this[C].length===0)throw new Error(`Wrong keyVersion! Found ${e} but you're using ${(o=this[T])===null||o===void 0?void 0:o.keyVersion}`);let a=this[C].find((i=>i.keyVersion===e));if(a||(yield this.getEncryptionSettings()),a=(this[C]||[]).find((i=>i.keyVersion===e)),!a)throw new Error(`Wrong keyVersion! Found ${e} but you're using ${(r=this[T])===null||r===void 0?void 0:r.keyVersion}`);return this.getEncryptionHandler?this.getEncryptionHandler(a):void 0}return this.encryptionHandler}))}handleEncryptionSettings(e){return p(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No getEncryptionHandler defined!");this[T]=e.encryptionSettings,this[C]=e.previousEncryptionSettings,this.encryptionHandler=yield this.getEncryptionHandler(e.encryptionSettings)}))}prepareEncryptionSettings(e){var t,n,o;return{encryptionSettings:{salt:Uint8Array.from(atob((t=e?.encryptionSettings)===null||t===void 0?void 0:t.salt),(r=>r.charCodeAt(0))),keyVersion:(n=e?.encryptionSettings)===null||n===void 0?void 0:n.keyVersion,createdAt:(o=e?.encryptionSettings)===null||o===void 0?void 0:o.createdAt},previousEncryptionSettings:(e?.previousEncryptionSettings||[]).map((r=>({salt:Uint8Array.from(atob(r?.salt),(a=>a.charCodeAt(0))),keyVersion:r?.keyVersion,createdAt:r?.createdAt})))}}getEncryptionSettings(e){return p(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const t=yield this.request("POST",`/cache-encryption/${this.class}/${this.id}`,e&&e>0?{saltLength:e}:{}),n=this.prepareEncryptionSettings(t);return yield this.handleEncryptionSettings(n),n}))}rotateEncryption(e){return p(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const t=yield this.request("POST",`/cache-encryption-rotate/${this.class}/${this.id}`,e&&e>0?{saltLength:e}:{}),n=this.prepareEncryptionSettings(t);return yield this.handleEncryptionSettings(n),n}))}request(e,t,n){return p(this,void 0,void 0,(function*(){!this[y].accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken);try{yield this.throttleManager.throttleOperation()}catch(o){throw this.logger.log("error",`Request throttled: ${o?.message}`),o}return L.executeWithRetry((()=>p(this,void 0,void 0,(function*(){var o;const r=this[y].apiKey&&this[y].apiSecret?`Basic ${btoa(`${this[y].apiKey}:${this[y].apiSecret}`)}`:void 0,a=this[y].accessToken?`Bearer ${this[y].accessToken}`:void 0;let i=this[y].accessToken?a:r;if(t==="/auth/token"&&(i=r),!i)throw new Error("No authentication option provided! (apiKey + apiSecret or accessToken)");const l={Authorization:i},d=typeof n=="string",s=(o=this[T])===null||o===void 0?void 0:o.keyVersion;s!==void 0&&s>-1&&(l["X-Enc-KV"]=s.toString()),this.idSignature&&(l["X-Id-Sig"]=this.idSignature,this.idSignatureKeyVersion!==void 0&&(l["X-Id-Sig-KV"]=this.idSignatureKeyVersion.toString())),n&&(l["Content-Type"]=d?"text/plain":"application/json");const c=yield fetch(`${L.basePath}/project/${this[y].projectId}${t}`,{method:e,headers:l,body:n?d?n:JSON.stringify(n):void 0}),h=c.headers.get("content-type");let u;if(h)try{h.indexOf("text/plain")===0?u=yield c.text():h.indexOf("application/json")===0&&(u=yield c.json())}catch{u=`${c.status} - ${c.statusText}`}if(!c.ok){if(typeof u=="string")throw new Error(u);if(u)throw u;if(c.status!==404)throw new Error(`${c.status} - ${c.statusText}`)}return u}))),"API request",this.logger)}))}}B=j,L.basePath="https://api.vaultrice.app";var Y;class M extends L{constructor(e,t){var n,o,r,a,i,l,d,s,c,h;super(e,t),this[Y]=new Map,this.reconnectAttempts=0,this.reconnectBaseDelay=1e3,this.reconnectMaxDelay=6e4,this.isConnected=!1,this.pingInterval=2e4,this.pongTimeout=1e4,this.hasJoined=!1,this[I]=[],this[V]=new Map;const u=typeof t=="object"?t:{};this.configuredAutoReconnect=(o=(n=u.connectionSettings)===null||n===void 0?void 0:n.autoReconnect)===null||o===void 0||o,this.autoReconnect=this.configuredAutoReconnect,this.reconnectBaseDelay=(a=(r=u.connectionSettings)===null||r===void 0?void 0:r.reconnectBaseDelay)!==null&&a!==void 0?a:1e3,this.reconnectMaxDelay=(l=(i=u.connectionSettings)===null||i===void 0?void 0:i.reconnectMaxDelay)!==null&&l!==void 0?l:3e4,this.pingInterval=(s=(d=u.connectionSettings)===null||d===void 0?void 0:d.pingInterval)!==null&&s!==void 0?s:2e4,this.pongTimeout=(h=(c=u.connectionSettings)===null||c===void 0?void 0:c.pongTimeout)!==null&&h!==void 0?h:1e4}send(e){return p(this,arguments,void 0,(function*(t,n={transport:"ws"}){var o,r,a;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(t)):t;if(n.transport==="http"){try{yield this.request("POST",`/message/${this.class}/${this.id}`,i)}catch(s){if(!s||((o=s?.cause)===null||o===void 0?void 0:o.code)!=="conflictError.keyVersion.mismatch")throw s;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),yield this.request("POST",`/message/${this.class}/${this.id}`,i)}return}const l=yield this.getWebSocket();try{yield this.throttleManager.throttleOperation()}catch(s){throw this.logger.log("error",`WebSocket message throttled: ${s?.message}`),s}const d={event:"message",payload:i};this[T]&&((r=this[T])===null||r===void 0?void 0:r.keyVersion)>-1&&(d.keyVersion=(a=this[T])===null||a===void 0?void 0:a.keyVersion),l.send(JSON.stringify(d))}))}on(e,t,n){this.getWebSocket(!1).then((o=>{this[V].has(e)||this[V].set(e,new Set);const r=this[V].get(e);if(e==="error"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t;this[I].push(i);const l=d=>{try{const s=d?.message||d?.data||d?.type||(typeof d=="string"?d:"WebSocket error occurred");i(new Error(s))}catch{i(new Error("WebSocket error occurred"))}};o.addEventListener("error",l),r.add({handler:i,wsListener:l})}if(e==="connect"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t;r.add({handler:i})}if(e==="disconnect"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,l=()=>i();o.addEventListener("close",l),r.add({handler:i,wsListener:l})}const a=(i,l,d=!1)=>{const s=d?i.keyVersion:i.payload.keyVersion;if(s===void 0)return l(i.payload);if(s>-1){if(!this.getEncryptionHandler)return this[I].forEach((h=>h(new Error("Encrypted data, but no passphrase or getEncryptionHandler configured!"))));if(!this.encryptionHandler)return this[I].forEach((h=>h(new Error("Encrypted data, but getEncryptionSettings() not called!"))));let c=i.payload.value;d&&(c=i.payload),this.getEncryptionHandlerForKeyVersion(s).then((h=>h?.decrypt(c))).then((h=>{d?i.payload=JSON.parse(h):i.payload.value=JSON.parse(h),l(i.payload)})).catch((h=>{this[I].forEach((u=>u(h)))}))}};if(e==="message"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,l=d=>{const s=JSON.parse(d.data);s.event==="message"&&a(s,i,!0)};o.addEventListener("message",l),r.add({handler:i,wsListener:l})}if(e==="presence:join"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,l=d=>{const s=JSON.parse(d.data);s.event==="presence:join"&&a(s,(c=>{i({connectionId:s?.connectionId,joinedAt:s?.joinedAt,data:c})}),!0)};o.addEventListener("message",l),r.add({handler:i,wsListener:l})}if(e==="presence:leave"){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,l=d=>{const s=JSON.parse(d.data);s.event==="presence:leave"&&a(s,(c=>{i({connectionId:s?.connectionId,data:c})}),!0)};o.addEventListener("message",l),r.add({handler:i,wsListener:l})}if(e==="setItem")if(n===void 0){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,l=d=>{const s=JSON.parse(d.data);s.event==="setItem"&&a(s,i)};o.addEventListener("message",l),r.add({handler:i,wsListener:l})}else{if(typeof n!="function")throw new Error("No event handler defined!");const i=n,l=t,d=s=>{const c=JSON.parse(s.data);c.event==="setItem"&&c.payload.prop===l&&a(c,i)};o.addEventListener("message",d),r.add({handler:i,wsListener:d,itemName:l})}if(e==="removeItem")if(n===void 0){if(typeof t!="function")throw new Error("No event handler defined!");const i=t,l=d=>{const s=JSON.parse(d.data);s.event==="removeItem"&&i(s.payload)};o.addEventListener("message",l),r.add({handler:i,wsListener:l})}else{if(typeof n!="function")throw new Error("No event handler defined!");const i=n,l=t,d=s=>{const c=JSON.parse(s.data);c.event==="removeItem"&&c.payload.prop===l&&i(c.payload)};o.addEventListener("message",d),r.add({handler:i,wsListener:d,itemName:l})}}))}off(e,t,n){const o=this[V].get(e);if(o){if(e==="error"){if(typeof t!="function")throw new Error("No event handler defined!");const r=t,a=this[I].indexOf(r);a>-1&&this[I].splice(a,1);for(const i of o)if(i.handler===r){this[k]&&i.wsListener&&this[k].removeEventListener("error",i.wsListener),o.delete(i);break}}else{if(!this[k])return;const r=this[k];let a,i;if(n===void 0){if(typeof t!="function")throw new Error("No event handler defined!");a=t}else{if(typeof n!="function")throw new Error("No event handler defined!");a=n,i=t}for(const l of o){const d=l.handler===a,s=i===void 0||l.itemName===i;if(d&&s){if(l.wsListener){const c=e==="connect"?"open":e==="disconnect"?"close":e==="error"?"error":"message";r.removeEventListener(c,l.wsListener)}o.delete(l);break}}}o.size===0&&this[V].delete(e),this[V].size===0&&this[I].length===0&&this.disconnect()}}connect(){return p(this,void 0,void 0,(function*(){this[k]||(yield this.getWebSocket())}))}disconnect(){return p(this,void 0,void 0,(function*(){this.autoReconnect=!1,this[k]&&(this.hasJoined&&(yield this.leave()),this[k].close(),delete this[k],this[V].clear(),this[I].length=0)}))}getWebSocket(){return p(this,arguments,void 0,(function*(e=!0){if(!this[y].accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken),this[k])return e&&this[k].readyState===WebSocket.CONNECTING?new Promise(((s,c)=>{const h=this[k],u=()=>{h.removeEventListener("open",S),h.removeEventListener("error",f),h.removeEventListener("close",x)},S=()=>{u(),s(h)},f=A=>{u(),c(A||new Error("WebSocket connection failed"))},x=()=>{u(),c(new Error("WebSocket connection closed during opening"))};h.readyState!==WebSocket.OPEN?(h.addEventListener("open",S,{once:!0}),h.addEventListener("error",f,{once:!0}),h.addEventListener("close",x,{once:!0})):s(h)})):this[k];this.autoReconnect=this.configuredAutoReconnect;const t=M.basePath.replace("http","ws"),n=this[y].apiKey&&this[y].apiSecret?`Basic ${btoa(`${this[y].apiKey}:${this[y].apiSecret}`)}`:void 0,o=this[y].accessToken?`Bearer ${this[y].accessToken}`:void 0,r={auth:this[y].accessToken?o:n};this.idSignature&&(r.idSignature=this.idSignature,this.idSignatureKeyVersion!==void 0&&(r.idSignatureKeyVersion=this.idSignatureKeyVersion));const a=new URLSearchParams(r),i=this[k]=new WebSocket(`${t}/project/${this[y].projectId}/ws/${this.class}/${this.id}?${a}`);this.logger.log("info","initializing WebSocket connection...");let l;i.addEventListener("message",(s=>{let c;try{c=typeof s.data=="string"?JSON.parse(s.data):void 0}catch{c=void 0}if(!c||typeof c!="object")return;const h=c.event;if(h){if(h!=="pong")if(h!=="connected"&&h!=="resume:ack"||!c.connectionId){if(h==="error"){const u=c.payload;if(typeof u=="string"&&u.toLowerCase().includes("invalid resume")&&(this.logger.log("warn","server signalled invalid resume token — clearing saved connectionId"),this.connectionId=void 0,typeof s.stopImmediatePropagation=="function"))try{s.stopImmediatePropagation()}catch{}}}else{this.connectionId=c.connectionId,this.isConnected=!0;const u=this[V].get("connect");if(u)for(const S of u)try{S.handler()}catch(f){this.logger.log("error",f)}if(typeof s.stopImmediatePropagation=="function")try{s.stopImmediatePropagation()}catch{}}else if(this.logger.log("debug","received pong"),this.clearPongTimer(),typeof s.stopImmediatePropagation=="function")try{s.stopImmediatePropagation()}catch{}}}));const d=new Promise((s=>{l=s}));return i.addEventListener("open",(()=>{if(this.reconnectAttempts=0,this.connectionId)try{i.send(JSON.stringify({event:"resume",connectionId:this.connectionId}))}catch{}this.startHeartbeat(),typeof l=="function"&&l(i)}),{once:!0}),i.addEventListener("close",(s=>{this.isConnected=!1,this.stopHeartbeat()}),{once:!0}),i.addEventListener("close",(s=>{s?.code===1008&&(this.logger.log("warn","WebSocket closed with 1008 during reconnection"),this.connectionId=void 0),s?.reason&&s?.reason.indexOf("TierLimitExceeded")>-1&&(this.autoReconnect=!1,this.logger.log("error",s.reason),this[I].forEach((u=>u(new Error(s.reason))))),delete this[k];const c=this.hasJoined,h=this.lastJoinData;if(this.hasJoined&&(this.hasJoined=!1),this.autoReconnect){const u=()=>p(this,void 0,void 0,(function*(){const S=Math.min(this.reconnectBaseDelay*Math.pow(2,this.reconnectAttempts),this.reconnectMaxDelay);setTimeout((()=>p(this,void 0,void 0,(function*(){let f;this.reconnectAttempts++,this.logger.log("warn",`${this.reconnectAttempts}. reconnection attempt...`);try{delete this[k],f=yield this.getWebSocket(!1)}catch(m){return this.logger.log("error",m?.message||m?.name||m?.type||m),void u()}const x=()=>p(this,void 0,void 0,(function*(){if(this.reconnectAttempts=0,!this[k])return;const m=this[k];for(const[$,J]of this[V])for(const O of J){let b;$==="connect"||($==="disconnect"?(b=()=>O.handler(),m.addEventListener("close",b)):$==="error"?(b=E=>{try{const v=E?.message||E?.data||E?.type||(typeof E=="string"?E:"WebSocket error occurred");O.handler(new Error(v))}catch{O.handler(new Error("WebSocket error occurred"))}},m.addEventListener("error",b)):$==="message"?(b=E=>{let v;try{v=typeof E.data=="string"?JSON.parse(E.data):void 0}catch{v=void 0}v&&v.event==="message"&&O.handler(v.payload)},m.addEventListener("message",b)):$==="presence:join"?(b=E=>{let v;try{v=typeof E.data=="string"?JSON.parse(E.data):void 0}catch{v=void 0}v&&v.event==="presence:join"&&O.handler(v.payload)},m.addEventListener("message",b)):$==="presence:leave"?(b=E=>{let v;try{v=typeof E.data=="string"?JSON.parse(E.data):void 0}catch{v=void 0}v&&v.event==="presence:leave"&&O.handler(v.payload)},m.addEventListener("message",b)):$==="setItem"?(b=E=>{let v;try{v=typeof E.data=="string"?JSON.parse(E.data):void 0}catch{v=void 0}v&&v.event==="setItem"&&(O.itemName&&v.payload.prop!==O.itemName||O.handler(v.payload))},m.addEventListener("message",b)):$==="removeItem"&&(b=E=>{let v;try{v=typeof E.data=="string"?JSON.parse(E.data):void 0}catch{v=void 0}v&&v.event==="removeItem"&&(O.itemName&&v.payload.prop!==O.itemName||O.handler(v.payload))},m.addEventListener("message",b))),b&&(O.wsListener=b)}c&&h&&(yield this.join(h))})),A=()=>{f?.removeEventListener("open",w),f?.removeEventListener("close",H),f?.removeEventListener("error",N)},w=()=>p(this,void 0,void 0,(function*(){yield x(),A()})),H=()=>{A(),u()},N=m=>{this.logger.log("error",m?.message||m?.name||m?.type||m),A(),u()};f.addEventListener("open",w,{once:!0}),f.addEventListener("close",H,{once:!0}),f.addEventListener("error",N,{once:!0}),f.readyState!==WebSocket.CLOSING&&f.readyState!==WebSocket.CLOSED?f.readyState===WebSocket.OPEN&&(yield x(),A()):u()}))),S)}));u()}})),e?d:i}))}clearPongTimer(){this.pongTimer&&(clearTimeout(this.pongTimer),this.pongTimer=void 0)}startPongTimer(){this.clearPongTimer(),this.pongTimer=setTimeout((()=>{var e;this.logger.log("warn","pong timeout — closing socket to reconnect");try{(e=this[k])===null||e===void 0||e.close(1006,"pong timeout")}catch{}}),this.pongTimeout)}stopHeartbeat(){this.pingTimer&&(clearInterval(this.pingTimer),this.pingTimer=void 0),this.clearPongTimer()}startHeartbeat(){this.stopHeartbeat();const e=this[k];if(e&&e.readyState===WebSocket.OPEN)try{e.send(JSON.stringify({event:"ping"})),this.startPongTimer()}catch{}this.pingTimer=setInterval((()=>{const t=this[k];if(t&&t.readyState===WebSocket.OPEN)try{t.send(JSON.stringify({event:"ping"})),this.startPongTimer()}catch{}}),this.pingInterval)}join(e){return p(this,void 0,void 0,(function*(){var t,n;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");try{yield this.throttleManager.throttleOperation()}catch(i){throw this.logger.log("error",`Request throttled: ${i?.message}`),i}this.hasJoined=!0,this.lastJoinData=e;const o=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e)):e,r=yield this.getWebSocket(),a={event:"presence:join",payload:o};this[T]&&((t=this[T])===null||t===void 0?void 0:t.keyVersion)>-1&&(a.keyVersion=(n=this[T])===null||n===void 0?void 0:n.keyVersion),r.send(JSON.stringify(a))}))}leave(){return p(this,void 0,void 0,(function*(){var e,t;if(!this.hasJoined)return;try{yield this.throttleManager.throttleOperation()}catch(r){throw this.logger.log("error",`Request throttled: ${r?.message}`),r}this.hasJoined=!1;const n=yield this.getWebSocket(),o={event:"presence:leave"};this[T]&&((e=this[T])===null||e===void 0?void 0:e.keyVersion)>-1&&(o.keyVersion=(t=this[T])===null||t===void 0?void 0:t.keyVersion),n.send(JSON.stringify(o))}))}getJoinedConnections(){return p(this,void 0,void 0,(function*(){if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const e=yield this.request("GET",`/presence-list/${this.class}/${this.id}`);if(!e||!Array.isArray(e))return[];const t=[];for(const o of e){if(!o?.data){t.push(o);continue}const r=yield this.getEncryptionHandlerForKeyVersion(o.keyVersion),a=r&&typeof o.data=="string"?JSON.parse(yield r.decrypt(o.data)):o.data;t.push(Object.assign(Object.assign({},o),{data:a}))}const n=this.connectionId;if(n){const o=t.findIndex((r=>r.connectionId===n));if(o>0){const r=t.splice(o,1)[0];t.unshift(r)}}return t}))}}Y=V;class ae extends M{constructor(e,t){typeof t=="string"?super(e,t):(super(e,t),t?.ttl&&(this.ttl=t?.ttl))}setItem(e,t,n){return p(this,void 0,void 0,(function*(){var o,r;if(!e)throw new Error("No name passed!");if(!t&&t!==0&&t!==""&&t!==!1)throw new Error("No value passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const a=n?.ttl||this.ttl,i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(t)):t;let l;try{l=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}`,{value:i,ttl:a,ifAbsent:n?.ifAbsent,updatedAt:n?.updatedAt})}catch(s){if(!s||((o=s?.cause)===null||o===void 0?void 0:o.code)!=="conflictError.keyVersion.mismatch")throw s;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),l=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}`,{value:i,ttl:a,ifAbsent:n?.ifAbsent})}const d=l;return d&&{value:d?.value,expiresAt:d?.expiresAt,keyVersion:(r=d?.keyVersion)!==null&&r!==void 0?r:void 0,createdAt:d?.createdAt,updatedAt:d?.updatedAt}}))}setItems(e){return p(this,void 0,void 0,(function*(){var t,n;if(!e||Object.keys(e).length===0)throw new Error("No items passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");for(const a of Object.keys(e)){const i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e[a].value)):e[a].value;e[a].value=i,(n=e[a]).ttl||(n.ttl=this.ttl)}let o;try{o=yield this.request("POST",`/cache/${this.class}/${this.id}`,e)}catch(a){if(!a||((t=a?.cause)===null||t===void 0?void 0:t.code)!=="conflictError.keyVersion.mismatch")throw a;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("POST",`/cache/${this.class}/${this.id}`,e)}const r=o;return Object.keys(r).reduce(((a,i)=>{var l,d,s,c,h,u,S,f,x,A;return a[i]={value:(d=(l=r[i])===null||l===void 0?void 0:l.value)!==null&&d!==void 0?d:null,expiresAt:(c=(s=r[i])===null||s===void 0?void 0:s.expiresAt)!==null&&c!==void 0?c:0,keyVersion:(u=(h=r[i])===null||h===void 0?void 0:h.keyVersion)!==null&&u!==void 0?u:void 0,createdAt:(f=(S=r[i])===null||S===void 0?void 0:S.createdAt)!==null&&f!==void 0?f:0,updatedAt:(A=(x=r[i])===null||x===void 0?void 0:x.updatedAt)!==null&&A!==void 0?A:0},a}),{})}))}getItem(e){return p(this,void 0,void 0,(function*(){var t,n;if(!e)throw new Error("No name passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let o;try{o=yield this.request("GET",`/cache/${this.class}/${this.id}/${e}`)}catch(d){if(!d||((t=d?.cause)===null||t===void 0?void 0:t.code)!=="conflictError.keyVersion.mismatch")throw d;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("GET",`/cache/${this.class}/${this.id}/${e}`)}const r=o,a=r?.value;if(!a)return;const i=yield this.getEncryptionHandlerForKeyVersion(r.keyVersion),l=i?JSON.parse(yield i.decrypt(a)):a;return r?.keyVersion>-1&&r.keyVersion!==((n=this[T])===null||n===void 0?void 0:n.keyVersion)&&(this.autoUpdateOldEncryptedValues?(this.logger.log("info",`Item "${e}" has an old encryption and will be automatically updated now by setting it again.`),yield this.setItem(e,l,{ttl:r.expiresAt-Date.now()})):this.logger.log("warn",`Item "${e}" has an old encryption and can be updated by setting it again.`)),{value:l,expiresAt:r.expiresAt,keyVersion:r.keyVersion,createdAt:r.createdAt,updatedAt:r.updatedAt}}))}getItems(e){return p(this,void 0,void 0,(function*(){var t,n;if(!e||e.length===0)throw new Error("No names passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let o;try{o=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,e)}catch(d){if(!d||((t=d?.cause)===null||t===void 0?void 0:t.code)!=="conflictError.keyVersion.mismatch")throw d;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,e)}const r=o;if(Object.keys(r).length===0)return;const a={},i={};for(const d of Object.keys(r)){const s=r[d],c=s?.value;if(!c)continue;const h=yield this.getEncryptionHandlerForKeyVersion(s.keyVersion),u=h?JSON.parse(yield h.decrypt(c)):c;s?.keyVersion>-1&&s.keyVersion!==((n=this[T])===null||n===void 0?void 0:n.keyVersion)&&(a[d]=s),i[d]={value:u,expiresAt:s.expiresAt,keyVersion:s.keyVersion,createdAt:s.createdAt,updatedAt:s.updatedAt}}const l=Object.keys(a);if(l.length>0)if(this.autoUpdateOldEncryptedValues){this.logger.log("info",`These items "${l.join(",")}" have an old encryption and will be automatically updated now by setting them again.`);const d=l.reduce(((s,c)=>(s[c]={value:i[c].value,ttl:a[c].expiresAt-Date.now()},s)),{});yield this.setItems(d)}else this.logger.log("warn",`These items "${l.join(",")}" have an old encryption and can be updated by setting them again.`);return i}))}getAllItems(e){return p(this,void 0,void 0,(function*(){var t,n;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let o;try{o=yield this.request("GET",`/cache/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}catch(i){if(!i||((t=i?.cause)===null||t===void 0?void 0:t.code)!=="conflictError.keyVersion.mismatch")throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("GET",`/cache/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}const r=o;if(Object.keys(r).length===0)return;const a={};for(const i of Object.keys(r)){const l=r[i],d=l?.value;if(!d)continue;const s=yield this.getEncryptionHandlerForKeyVersion(l.keyVersion),c=s?JSON.parse(yield s.decrypt(d)):d;a[i]={value:c,expiresAt:l.expiresAt,keyVersion:(n=l.keyVersion)!==null&&n!==void 0?n:void 0,createdAt:l.createdAt,updatedAt:l.updatedAt}}return a}))}getAllKeys(e){return p(this,void 0,void 0,(function*(){return yield this.request("GET",`/cache-keys/${this.class}/${this.id}${e?.prefix?`?prefix=${e?.prefix}`:""}`)}))}removeItem(e){return p(this,void 0,void 0,(function*(){if(!e)throw new Error("No name passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}/${e}`)}))}removeItems(e){return p(this,void 0,void 0,(function*(){if(!e||e.length===0)throw new Error("No names passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}`,e)}))}incrementItem(e){return p(this,arguments,void 0,(function*(t,n=1,o){var r;if(!t)throw new Error("No name passed!");if(n==null)throw new Error("No value passed!");if(typeof n!="number")throw new Error("Value needs to be a number!");const a=o?.ttl||this.ttl,i=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}/increment`,{value:n,ttl:a,updatedAt:o?.updatedAt});return{value:i?.value,expiresAt:i?.expiresAt,keyVersion:(r=i?.keyVersion)!==null&&r!==void 0?r:void 0,createdAt:i?.createdAt,updatedAt:i?.updatedAt}}))}decrementItem(e){return p(this,arguments,void 0,(function*(t,n=1,o){var r;if(!t)throw new Error("No name passed!");if(n==null)throw new Error("No value passed!");if(typeof n!="number")throw new Error("Value needs to be a number!");const a=o?.ttl||this.ttl,i=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}/decrement`,{value:n,ttl:a,updatedAt:o?.updatedAt});return{value:i?.value,expiresAt:i?.expiresAt,keyVersion:(r=i?.keyVersion)!==null&&r!==void 0?r:void 0,createdAt:i?.createdAt,updatedAt:i?.updatedAt}}))}push(e,t,n){return p(this,void 0,void 0,(function*(){var o;if(!e)throw new Error("No name passed!");const r=n?.ttl||this.ttl,a=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/push`,{value:t,ttl:r,updatedAt:n?.updatedAt});return{value:a?.value,expiresAt:a?.expiresAt,keyVersion:(o=a?.keyVersion)!==null&&o!==void 0?o:void 0,createdAt:a?.createdAt,updatedAt:a?.updatedAt}}))}splice(e,t,n,o,r){return p(this,void 0,void 0,(function*(){var a;if(!e)throw new Error("No name passed!");const i=r?.ttl||this.ttl,l=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/splice`,{startIndex:t,deleteCount:n,items:o,ttl:i,updatedAt:r?.updatedAt});return{value:l?.value,expiresAt:l?.expiresAt,keyVersion:(a=l?.keyVersion)!==null&&a!==void 0?a:void 0,createdAt:l?.createdAt,updatedAt:l?.updatedAt}}))}merge(e,t,n){return p(this,void 0,void 0,(function*(){var o;if(!e)throw new Error("No name passed!");const r=n?.ttl||this.ttl,a=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/merge`,{value:t,ttl:r,updatedAt:n?.updatedAt});return{value:a?.value,expiresAt:a?.expiresAt,keyVersion:(o=a?.keyVersion)!==null&&o!==void 0?o:void 0,createdAt:a?.createdAt,updatedAt:a?.updatedAt}}))}setIn(e,t,n,o){return p(this,void 0,void 0,(function*(){var r;if(!e)throw new Error("No name passed!");if(!t||t.length===0)throw new Error("Path must not be empty.");const a=o?.ttl||this.ttl,i=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/set-in`,{path:t,value:n,ttl:a,updatedAt:o?.updatedAt});return{value:i?.value,expiresAt:i?.expiresAt,keyVersion:(r=i?.keyVersion)!==null&&r!==void 0?r:void 0,createdAt:i?.createdAt,updatedAt:i?.updatedAt}}))}clear(){return p(this,void 0,void 0,(function*(){yield this.request("DELETE",`/cache/${this.class}/${this.id}`)}))}}const W={};function de(g,e){return`${`${e.projectId}-${e.apiKey}`}-${`${g.class||"_undefined_"}-${g.id}`}`}const he=(g,e)=>{const t=e||X(),n=de(g,t);if(W[n])return W[n];const o=new ae(t,g);return W[n]=o,o};export{he as e};
